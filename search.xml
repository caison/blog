<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>日志打印规范及技巧学习总结</title>
      <link href="/2019/10/13/ri-zhi-da-yin-gui-fan-ji-ji-qiao-xue-xi-zong-jie/"/>
      <url>/2019/10/13/ri-zhi-da-yin-gui-fan-ji-ji-qiao-xue-xi-zong-jie/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E8%A7%84%E8%8C%83%E5%8F%8A%E6%8A%80%E5%B7%A7%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/0.jpg" alt></p><h1 id="一、日志打印级别"><a href="#一、日志打印级别" class="headerlink" title="一、日志打印级别"></a>一、日志打印级别</h1><ul><li><strong>DEBUG（调试）</strong><br><strong>开发调试日志</strong>。一般来说，在系统实际运行过程中，不会输出该级别的日志。因此，开发人员可以打印任何自己觉得有利于了解系统运行状态的东东。不过很多场景下，过多的DEBUG日志，并不是好事，建议是按照业务逻辑的走向打印。</li><li><strong>INFO（通知）</strong><br>INFO日志级别主要用于记录系统运行状态等关联信息。该日志级别，<strong>常用于反馈系统当前状态给最终用户</strong>。所以，在这里输出的信息，应该对最终用户具有实际意义，也就是最终用户要能够看得明白是什么意思才行。</li><li><strong>WARN（警告）</strong><br>WARN日志常用来表示<strong>系统模块发生问题，但并不影响系统运行</strong>。 此时，进行一些修复性的工作，还能把系统恢复到正常的状态。</li><li><strong>ERROR（错误）</strong></li><li><em>此信息输出后，主体系统核心模块正常工作，需要修复才能正常工作*</em>。 就是说可以进行一些修复性的工作，但无法确定系统会正常的工作下去，系统在以后的某个阶段，很可能会因为当前的这个问题，导致一个无法修复的错误（例如宕机），但也可能一直工作到停止也不出现严重问题。</li></ul><h1 id="二、日志打印规范"><a href="#二、日志打印规范" class="headerlink" title="二、日志打印规范"></a>二、日志打印规范</h1><blockquote><p><strong>1. 【强制</strong>】应用中不可直接使用日志系统 （Log 4 j 、 Logback） 中的 API ，而应依赖使用日志框架<br>SLF 4 J 中的 API ，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Logger<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>LoggerFactory<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger logger <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>Abc<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><ol start="2"><li>【强制】日志文件推荐至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。</li></ol></blockquote><p>可以结合实际业务需求，基于按天，和按照容量配置appender。例如，按天保存接口对接基本关键数值记录日志，按照容量保存接口对接详细日志。</p><blockquote><ol start="3"><li>【强制】应用中的扩展日志 （ 如打点、临时监控、访问日志等 ） </li></ol><ul><li><strong>命名方式：</strong>appName _ logType _ logName . log 。</li><li><strong>日志类型（ logType），推荐分类有stats / desc / monitor / visit 等</strong>。</li><li><strong>日志描述（logName）</strong>。<br>这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于通过日志对系统进行及时监控。</li><li><em>正例： mppserver 应用中单独监控时区转换异常，如：mppserver _ monitor _ timeZoneConvert . log*</em></li></ul></blockquote><blockquote><ol start="4"><li>【强制】对 trace / debug / info 级别的日志输出，必须使用条件输出形式或者使用占位符的方式。<br>说明： logger . debug( “ Processing trade with id : “ +  id + “  and symbol : “ +  symbol)。如果日志级别是 warn ，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol 是对象，会执行 toString() 方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。<br>正例： （ 占位符 ）<br>logger.debug(“Processing trade with id: {} and symbol : {} “, id, symbol);</li></ol></blockquote><blockquote><ol start="5"><li>【强制】避免重复打印日志，浪费磁盘空间，务必在 log 4 j . xml 中设置 additivity = false 。<br>正例： <logger name="com.taobao.dubbo.config" additivity="false"> </logger></li></ol></blockquote><blockquote><ol start="6"><li>【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 throws 往上抛出。<br>正例： logger.error(各类参数或者对象 toString  +  “_”  + e.getMessage(), e);</li></ol></blockquote><blockquote><ol start="7"><li>【推荐】谨慎地记录日志。生产环境禁止输出 debug 日志 ； 有选择地输出 info 日志 ； 如果使用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。<br>说明：大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？</li></ol></blockquote><blockquote><ol start="8"><li>【参考】可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。注意日志输出的级别， error 级别只记录系统逻辑出错、异常等重要的错误信息。如非必要，请不要在此场景打出 error 级别。</li></ol></blockquote><h1 id="三、日志打印技巧"><a href="#三、日志打印技巧" class="headerlink" title="三、日志打印技巧"></a>三、日志打印技巧</h1><h2 id="问题排查的日志"><a href="#问题排查的日志" class="headerlink" title="问题排查的日志"></a>问题排查的日志</h2><ul><li><p><strong>对接外部的调用封装</strong>：<br>程序中对接外部系统与模块的依赖调用前后都记下日志，方便接口调试。出问题时也可以很快理清是哪块的问题 </p><pre class=" language-java"><code class="language-java">LOG<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Calling external system:"</span> <span class="token operator">+</span> parameters<span class="token punctuation">)</span><span class="token punctuation">;</span>  Object result <span class="token operator">=</span> null<span class="token punctuation">;</span>  <span class="token keyword">try</span> <span class="token punctuation">{</span>    result <span class="token operator">=</span> <span class="token function">callRemoteSystem</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">;</span>    LOG<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Called successfully. result is "</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    LOG<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"Failed at calling xxx system . exception : "</span> <span class="token operator">+</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  </code></pre></li><li><p>状态变化：<br>程序中重要的状态信息的变化应该记录下来，方便查问题时还原现场，推断程序运行过程 </p><pre class=" language-java"><code class="language-java"><span class="token keyword">boolean</span> isRunning <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  LOG<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"System is running"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//...  </span>isRunning <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  LOG<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"System was interrupted by "</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre></li><li><p>系统入口与出口： </p><pre class=" language-java"><code class="language-java">这个粒度可以是重要方法级或模块级。记录它的输入与输出，方便定位 <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Object input<span class="token punctuation">)</span> <span class="token punctuation">{</span>    LOG<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Invoke parames : "</span> <span class="token operator">+</span> input<span class="token punctuation">)</span><span class="token punctuation">;</span>    Object result <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//business logical  </span>  LOG<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Method result : "</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  </code></pre></li><li><p>业务异常：<br>任何业务异常都应该记下来 </p><pre class=" language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//business logical  </span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    LOG<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"Description xxx"</span> <span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BusinessException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    LOG<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"Let me know anything"</span>，e<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    LOG<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Description xxx"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">invoke</span><span class="token punctuation">(</span>Object primaryParam<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>primaryParam <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        LOG<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span>原因<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span> </code></pre></li><li><p>非预期执行：<br>为程序在“有可能”执行到的地方打印日志。如果我想删除一个文件，结果返回成功。但事实上，那个文件在你想删除之前就不存在了。最终结果是一致的，但程序得让我们知道这种情况，要查清为什么文件在删除之前就已经不存在呢 </p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> myValue <span class="token operator">=</span> xxxx<span class="token punctuation">;</span>  <span class="token keyword">int</span> absResult <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>myValue<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>absResult <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    LOG<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Original int "</span> <span class="token operator">+</span> myValue <span class="token operator">+</span> <span class="token string">"has nagetive abs "</span> <span class="token operator">+</span> absResult<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  </code></pre></li><li><p>很少出现的else情况：<br>else可能吞掉你的请求，或是赋予难以理解的最终结果 </p><pre class=" language-java"><code class="language-java">Object result <span class="token operator">=</span> null<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>running<span class="token punctuation">)</span> <span class="token punctuation">{</span>   result <span class="token operator">=</span> xxx<span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>   result <span class="token operator">=</span> yyy<span class="token punctuation">;</span>   LOG<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"System does not running, we change the final result"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  </code></pre><h2 id="程序运行状态的日志"><a href="#程序运行状态的日志" class="headerlink" title="程序运行状态的日志"></a>程序运行状态的日志</h2><p>程序在运行时就像一个机器人，我们可以从它的日志看出它正在做什么，是不是按预期的设计在做，所以这些正常的运行状态是要有的。 </p></li><li><p>程序运行时间： </p><pre class=" language-java"><code class="language-java"><span class="token keyword">long</span> startTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> LOG<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"execution cost : "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　 </code></pre></li></ul><p>大批量数据的执行进度： </p><pre class=" language-java"><code class="language-java">LOG<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"current progress: "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>currentPos <span class="token operator">*</span> <span class="token number">100</span> <span class="token operator">/</span> totalAmount<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"%"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p>关键变量及正在做哪些重要的事情：<br>执行关键的逻辑，做IO操作等等 </p><pre class=" language-java"><code class="language-java">String <span class="token function">getJVMPid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     String pid <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// Obtains JVM process ID  </span>   LOG<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"JVM pid is "</span> <span class="token operator">+</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> pid<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">invokeRemoteMethod</span><span class="token punctuation">(</span>Object params<span class="token punctuation">)</span> <span class="token punctuation">{</span>      LOG<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Calling remote method : "</span> <span class="token operator">+</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//Calling remote server  </span><span class="token punctuation">}</span> </code></pre><h1 id="四、需要规避的问题"><a href="#四、需要规避的问题" class="headerlink" title="四、需要规避的问题"></a>四、需要规避的问题</h1><ul><li><p>频繁打印大数据量日志：<br>当日志产生的速度大于日志文件写磁盘的速度，会导致日志内容积压在内存中，导致内存泄漏。</p></li><li><p>无意义的Log：<br>日志不包含有意义的信息: 你肯定想知道的是哪个文件不存在吧 </p><pre class=" language-java"><code class="language-java">File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"xxx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>file<span class="token punctuation">.</span><span class="token function">isExist</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    LOG<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"File does not exist"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//Useless message  </span><span class="token punctuation">}</span> </code></pre></li><li><p>混淆信息的Log：<br>日志应该是清晰准确的: 当看到日志的时候，你知道是因为连接池取不到连接导致的问题么？</p><pre class=" language-java"><code class="language-java">Connection connection <span class="token operator">=</span> ConnectionFactory<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>connection <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    LOG<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"System initialized unsuccessfully"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  </code></pre><p>参考：<br>《阿里巴巴开发手册》<br><a href="http://blog.csdn.net/rogger_chen/article/details/50587920" target="_blank" rel="noopener">Logger日志级别说明及设置方法、说明</a><br><a href="http://langyu.iteye.com/blog/1147992" target="_blank" rel="noopener">闲谈程序中如何打印log</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线程的5种状态总结</title>
      <link href="/2019/10/13/xian-cheng-de-5-chong-zhuang-tai-zong-jie/"/>
      <url>/2019/10/13/xian-cheng-de-5-chong-zhuang-tai-zong-jie/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E7%BA%BF%E7%A8%8B%E7%9A%845%E7%A7%8D%E7%8A%B6%E6%80%81%E6%80%BB%E7%BB%93/0.jpg" alt></p><p>##线程的5种状态<br>线程可以有如下5种状态：<br>5种状态的转换图如下</p><p><img src="/images/%E7%BA%BF%E7%A8%8B%E7%9A%845%E7%A7%8D%E7%8A%B6%E6%80%81%E6%80%BB%E7%BB%93/1.png" alt="线程状态转换图"></p><p>####New (新创建)<br>*　　<em>当用*</em>new**操作符创建一个线程时，如new Thread(r)，该线程还没有开始运行。这意外这它的状态是new。此时程序还没有开始运行线程中的代码，在线程运行之前还有一些基础工作要做。</p><p>####Runnable (可运行/就绪)<br>*　　<em>一旦处于新状态的线程调用*</em>start**方法(如图中的1所示)，线程就处于Runnbale状态。<br>*　　*处于Runnable状态的线程还未运行run()方法的代码，只有在获得CPU时间片才开始运行。</p><p>####Running (运行中)<br>*　　*当线程获得CPU时间片，线程就进入Running状态(如图中的2所示)。<br>处于Running状态的线程有可能在运行中CPU时间片用完，而run方法没运行完，线程就又进入Runnable状态。<br>*　　*通常情况下，运行中的线程一直处于Running与Runnable交替转换的过程中。</p><p>####Blocked (等待/阻塞/睡眠)<br>*　　<em>当线程在Running状态中，遇到*</em>阻塞等待锁<strong>、</strong>等待用户输入<strong>、</strong>调用sleep()方法<strong>、</strong>调用join等待其他线程**情况，会导致线程进入阻塞状态(Blocked)。<br>*　　*处于阻塞状态的线程，在阻塞等待结束之后，会进入Runnable状态，等等获得CPU时间片继续运行程序。</p><p>####Dead (死亡)<br>*　　*当线程运行完run方法，直接进入死亡状态Dead 。</p><h2 id="代码中获得线程信息"><a href="#代码中获得线程信息" class="headerlink" title="代码中获得线程信息"></a>代码中获得线程信息</h2><p>在程序运行中，在代码中打印线程的信息（线程id,hashCode,name,id,priority,state等），方法如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getCurrentThreadInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Object<span class="token operator">></span> threadInfoMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        threadInfoMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"hashCode"</span><span class="token punctuation">,</span>current<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        threadInfoMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span>current<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        threadInfoMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">,</span>current<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        threadInfoMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"priority"</span><span class="token punctuation">,</span>current<span class="token punctuation">.</span><span class="token function">getPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        threadInfoMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"state"</span><span class="token punctuation">,</span>current<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>threadInfoMap<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h2 id="查看线程正在执行的代码"><a href="#查看线程正在执行的代码" class="headerlink" title="查看线程正在执行的代码"></a>查看线程正在执行的代码</h2><p>在程序运行的过程中，可以基于jstack查看线程正在执行的堆栈信息，示例：<br>jstack 10765 | grep ‘0x2a34’ -C5 –color<br>其中，’10765’是进程id,’0x2a34’是16进制的线程id<br><img src="/images/%E7%BA%BF%E7%A8%8B%E7%9A%845%E7%A7%8D%E7%8A%B6%E6%80%81%E6%80%BB%E7%BB%93/2.png" alt="线程堆栈信息"><br>#####参考文献<br>1、《Java核心技术 卷I》<br>2、<a href="https://mp.weixin.qq.com/s/Xb1im4jG_Cobhas4q4YT1Q" target="_blank" rel="noopener">《线上服务CPU100%问题快速定位实战》</a></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-行为型模式</title>
      <link href="/2019/10/13/she-ji-mo-shi-xing-wei-xing-mo-shi/"/>
      <url>/2019/10/13/she-ji-mo-shi-xing-wei-xing-mo-shi/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/0.jpg" alt></p><h1 id="中介者模式-Mediator"><a href="#中介者模式-Mediator" class="headerlink" title="中介者模式(Mediator)"></a>中介者模式(Mediator)</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/1.png" alt="中介者模式"><strong>意图：</strong>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<br><strong>主要解决：</strong>对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。</p><h1 id="命令模式-Command"><a href="#命令模式-Command" class="headerlink" title="命令模式(Command)"></a>命令模式(Command)</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/2.png" alt="命令模式"><br><strong>意图：</strong>将一个请求封装成一个对象，从而使得行为请求者和行为实现者解耦合。<br><strong>主要解决：</strong>在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</p><h1 id="备忘录模式-Memento"><a href="#备忘录模式-Memento" class="headerlink" title="备忘录模式(Memento)"></a>备忘录模式(Memento)</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/3.png" alt="备忘录模式"><br><strong>意图：</strong>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。<br><strong>主要解决：</strong>所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。</p><h1 id="模板方法模式-Template"><a href="#模板方法模式-Template" class="headerlink" title="模板方法模式(Template)"></a>模板方法模式(Template)</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/4.png" alt="模板方法模式"><br><strong>意图：</strong>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br><strong>主要解决：</strong>一些方法通用，却在每一个子类都重新写了这一方法。</p><h1 id="状态模式-State"><a href="#状态模式-State" class="headerlink" title="状态模式(State)"></a>状态模式(State)</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/5.png" alt="状态模式"><strong>意图：</strong>将特定状态相关的逻辑分散到一些类的状态类中<br><strong>主要解决：</strong>对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。</p><h1 id="策略模式-Strategy"><a href="#策略模式-Strategy" class="headerlink" title="策略模式(Strategy)"></a>策略模式(Strategy)</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/6.png" alt="策略模式"><strong>意图：</strong>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。<br><strong>主要解决：</strong>在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</p><h1 id="观察者模式-Observer"><a href="#观察者模式-Observer" class="headerlink" title="观察者模式(Observer)"></a>观察者模式(Observer)</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/7.png" alt="观察者模式"><br><strong>意图：</strong>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。<br><strong>主要解决：</strong>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p><h1 id="解释器模式-Interpreter"><a href="#解释器模式-Interpreter" class="headerlink" title="解释器模式(Interpreter )"></a>解释器模式(Interpreter )</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/8.png" alt="解释器模式"><strong>意图：</strong>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。<br><strong>主要解决：</strong>对于一些固定文法构建一个解释句子的解释器。</p><h1 id="访问者模式-Visitor"><a href="#访问者模式-Visitor" class="headerlink" title="访问者模式(Visitor)"></a>访问者模式(Visitor)</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/9.png" alt="访问者模式"><strong>意图：</strong>主要将数据结构与数据访问操作分离。<br><strong>主要解决：</strong>稳定的数据结构和易变的访问操作耦合问题。</p><h1 id="责任链模式-Chain-of-Responsibility"><a href="#责任链模式-Chain-of-Responsibility" class="headerlink" title="责任链模式(Chain of Responsibility)"></a>责任链模式(Chain of Responsibility)</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/10.png" alt="责任链模式"><strong>意图：</strong>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。<br><strong>主要解决：</strong>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p><h1 id="迭代器模式-Iterator"><a href="#迭代器模式-Iterator" class="headerlink" title="迭代器模式(Iterator)"></a>迭代器模式(Iterator)</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/11.png" alt="迭代器模式"><strong>意图：</strong>提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。<br><strong>主要解决：</strong>不同的方式来遍历整个整合对象。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-创建型模式</title>
      <link href="/2019/10/13/she-ji-mo-shi-chuang-jian-xing-mo-shi/"/>
      <url>/2019/10/13/she-ji-mo-shi-chuang-jian-xing-mo-shi/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/0.jpg" alt></p><h1 id="原型模式-Prototype"><a href="#原型模式-Prototype" class="headerlink" title="原型模式(Prototype )"></a>原型模式(Prototype )</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/1.png" alt="原型模式"><br><strong>意图：</strong>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<br><strong>主要解决：</strong>在运行期建立和删除原型。</p><h1 id="建造者模式-Builder"><a href="#建造者模式-Builder" class="headerlink" title="建造者模式(Builder)"></a>建造者模式(Builder)</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/2.png" alt="建造者模式"><strong>意图：</strong>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br><strong>主要解决：</strong>主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p><h1 id="单例模式-Sington"><a href="#单例模式-Sington" class="headerlink" title="单例模式(Sington)"></a>单例模式(Sington)</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/3.png" alt="单例模式"><br><strong>意图：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br><strong>主要解决：</strong>一个全局使用的类频繁地创建与销毁。</p><h1 id="抽象工厂模式-Abstract-Factory"><a href="#抽象工厂模式-Abstract-Factory" class="headerlink" title="抽象工厂模式(Abstract Factory)"></a>抽象工厂模式(Abstract Factory)</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/4.png" alt="抽象工厂模式"><strong>意图：</strong>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br><strong>主要解决：</strong>主要解决接口选择的问题。</p><h1 id="工厂方法模式-Factory-Method"><a href="#工厂方法模式-Factory-Method" class="headerlink" title="工厂方法模式(Factory Method)"></a>工厂方法模式(Factory Method)</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/5.png" alt="工厂方法模式"><strong>意图：</strong>暴露一个创建对象的方法，允许客户端创建不同工厂来生产产品。<br><strong>主要解决：</strong>创建对象的接口，让子类去决定具体实例化的对象，把简单的内部逻辑判断移到了客户端代码。</p><h1 id="简单工厂模式-Static-Factory-Method"><a href="#简单工厂模式-Static-Factory-Method" class="headerlink" title="简单工厂模式(Static Factory Method)"></a>简单工厂模式(Static Factory Method)</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/6.png" alt="简单工厂模式">又称为静态工厂<br><strong>意图：</strong>由一个工厂对象决定创建出哪一种产品类的实例。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>理解Java中SPI机制</title>
      <link href="/2019/10/13/li-jie-java-zhong-spi-ji-zhi/"/>
      <url>/2019/10/13/li-jie-java-zhong-spi-ji-zhi/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E7%90%86%E8%A7%A3Java%E4%B8%ADSPI%E6%9C%BA%E5%88%B6/0.jpg" alt></p><pre><code>文章首发于Hollis公众号作者 陈彩华文章转载交流请联系 caison@aliyun.com</code></pre><p>本文通过探析JDK提供的，在开源项目中比较常用的Java SPI机制，希望给大家在实际开发实践、学习开源项目提供参考。</p><h1 id="1-SPI是什么"><a href="#1-SPI是什么" class="headerlink" title="1 SPI是什么"></a>1 SPI是什么</h1><p>SPI全称Service Provider Interface，是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件。</p><p>整体机制图如下：<br><img src="/images/%E7%90%86%E8%A7%A3Java%E4%B8%ADSPI%E6%9C%BA%E5%88%B6/1.png" alt><br>Java SPI 实际上是“<strong>基于接口的编程＋策略模式＋配置文件</strong>”组合实现的动态加载机制。</p><p>系统设计的各个抽象，往往有很多不同的实现方案，在面向的对象的设计里，一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。<br>Java SPI就是提供这样的一个机制：为某个接口寻找服务实现的机制。有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。所以SPI的核心思想就是<strong>解耦</strong>。</p><h1 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2 使用场景"></a>2 使用场景</h1><p>概括地说，适用于：<strong>调用者根据实际使用需要，启用、扩展、或者替换框架的实现策略</strong></p><p>比较常见的例子：</p><ul><li>数据库驱动加载接口实现类的加载<br>JDBC加载不同类型数据库的驱动</li><li>日志门面接口实现类加载<br>SLF4J加载不同提供商的日志实现类</li><li>Spring<br>Spring中大量使用了SPI,比如：对servlet3.0规范对ServletContainerInitializer的实现、自动类型转换Type Conversion SPI(Converter SPI、Formatter SPI)等</li><li>Dubbo<br>Dubbo中也大量使用SPI的方式实现框架的扩展, 不过它对Java提供的原生SPI做了封装，允许用户扩展实现Filter接口</li></ul><h1 id="3-使用介绍"><a href="#3-使用介绍" class="headerlink" title="3 使用介绍"></a>3 使用介绍</h1><p>要使用Java SPI，需要遵循如下约定：</p><ul><li>1、当服务提供者提供了接口的一种具体实现后，在jar包的META-INF/services目录下创建一个以“接口全限定名”为命名的文件，内容为实现类的全限定名；</li><li>2、接口实现类所在的jar包放在主程序的classpath中；</li><li>3、主程序通过java.util.ServiceLoder动态装载实现模块，它通过扫描META-INF/services目录下的配置文件找到实现类的全限定名，把类加载到JVM；</li><li>4、SPI的实现类必须携带一个不带参数的构造方法；</li></ul><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p><strong>步骤1</strong>、定义一组接口 (假设是org.foo.demo.IShout)，并写出接口的一个或多个实现，(假设是org.foo.demo.animal.Dog、org.foo.demo.animal.Cat)。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IShout</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">shout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">implements</span> <span class="token class-name">IShout</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"miao miao"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">implements</span> <span class="token class-name">IShout</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"wang wang"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>步骤2</strong>、在 src/main/resources/ 下建立 /META-INF/services 目录， 新增一个以接口命名的文件 (org.foo.demo.IShout文件)，内容是要应用的实现类（这里是org.foo.demo.animal.Dog和org.foo.demo.animal.Cat，每行一个类）。</p><p>文件位置</p><pre class=" language-java"><code class="language-java"><span class="token operator">-</span> src    <span class="token operator">-</span>main        <span class="token operator">-</span>resources            <span class="token operator">-</span> META<span class="token operator">-</span>INF                <span class="token operator">-</span> services                    <span class="token operator">-</span> org<span class="token punctuation">.</span>foo<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>IShout</code></pre><p>文件内容</p><pre class=" language-java"><code class="language-java">org<span class="token punctuation">.</span>foo<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>animal<span class="token punctuation">.</span>Dogorg<span class="token punctuation">.</span>foo<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>animal<span class="token punctuation">.</span>Cat</code></pre><p><strong>步骤3</strong>、使用 ServiceLoader 来加载配置文件中指定的实现。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SPIMain</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ServiceLoader<span class="token operator">&lt;</span>IShout<span class="token operator">></span> shouts <span class="token operator">=</span> ServiceLoader<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>IShout<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>IShout s <span class="token operator">:</span> shouts<span class="token punctuation">)</span> <span class="token punctuation">{</span>            s<span class="token punctuation">.</span><span class="token function">shout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>代码输出：</p><pre class=" language-java"><code class="language-java">wang wangmiao miao</code></pre><h1 id="4-原理解析"><a href="#4-原理解析" class="headerlink" title="4 原理解析"></a>4 原理解析</h1><p>首先看ServiceLoader类的签名类的成员变量：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ServiceLoader</span><span class="token operator">&lt;</span>S<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Iterable</span><span class="token operator">&lt;</span>S<span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String PREFIX <span class="token operator">=</span> <span class="token string">"META-INF/services/"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 代表被加载的类或者接口</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Class<span class="token operator">&lt;</span>S<span class="token operator">></span> service<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 用于定位，加载和实例化providers的类加载器</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> ClassLoader loader<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建ServiceLoader时采用的访问控制上下文</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> AccessControlContext acc<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 缓存providers，按实例化的顺序排列</span>    <span class="token keyword">private</span> LinkedHashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>S<span class="token operator">></span> providers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 懒查找迭代器</span>    <span class="token keyword">private</span> LazyIterator lookupIterator<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>参考具体ServiceLoader具体源码，代码量不多，加上注释一共587行，梳理了一下，实现的流程如下：</p><ul><li><p>1 应用程序调用ServiceLoader.load方法<br>ServiceLoader.load方法内先创建一个新的ServiceLoader，并实例化该类中的成员变量，包括： </p><ul><li>loader(ClassLoader类型，类加载器)</li><li>acc(AccessControlContext类型，访问控制器)</li><li>providers(LinkedHashMap&lt;String,S&gt;类型，用于缓存加载成功的类)</li><li>lookupIterator(实现迭代器功能)</li></ul></li><li><p>2 应用程序通过迭代器接口获取对象实例<br>ServiceLoader先判断成员变量providers对象中(LinkedHashMap&lt;String,S&gt;类型)是否有缓存实例对象，如果有缓存，直接返回。<br>如果没有缓存，执行类的装载，实现如下：</p></li><li><p>(1) 读取META-INF/services/下的配置文件，获得所有能被实例化的类的名称，值得注意的是，ServiceLoader<strong>可以跨越jar包获取META-INF下的配置文件</strong>，具体加载配置的实现代码如下： </p><pre><code>      try {          String fullName = PREFIX + service.getName();          if (loader == null)              configs = ClassLoader.getSystemResources(fullName);          else              configs = loader.getResources(fullName);      } catch (IOException x) {          fail(service, &quot;Error locating configuration files&quot;, x);      }</code></pre></li><li><p>(2) 通过反射方法Class.forName()加载类对象，并用instance()方法将类实例化。</p></li><li><p>(3) 把实例化后的类缓存到providers对象中，(LinkedHashMap&lt;String,S&gt;类型）<br>然后返回实例对象。</p></li></ul><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><p><strong>优点</strong>：<br>使用Java SPI机制的优势是实现解耦，使得第三方服务模块的装配控制的逻辑与调用者的业务代码分离，而不是耦合在一起。应用程序可以根据实际业务情况启用框架扩展或替换框架组件。</p><p>相比使用提供接口jar包，供第三方服务模块实现接口的方式，SPI的方式使得源框架，不必关心接口的实现类的路径，可以不用通过下面的方式获取接口实现类：</p><ul><li>代码硬编码import 导入实现类</li><li>指定类全路径反射获取：例如在JDBC4.0之前，JDBC中获取数据库驱动类需要通过<strong>Class.forName(“com.mysql.jdbc.Driver”)</strong>，类似语句先动态加载数据库相关的驱动，然后再进行获取连接等的操作</li><li>第三方服务模块把接口实现类实例注册到指定地方，源框架从该处访问实例</li></ul><p>通过SPI的方式，第三方服务模块实现接口后，在第三方的项目代码的META-INF/services目录下的配置文件指定实现类的全路径名，源码框架即可找到实现类</p><p><strong>缺点</strong>：</p><ul><li>虽然ServiceLoader也算是使用的延迟加载，但是基本只能通过遍历全部获取，也就是接口的实现类全部加载并实例化一遍。如果你并不想用某些实现类，它也被加载并实例化了，这就造成了浪费。获取某个实现类的方式不够灵活，只能通过Iterator形式获取，不能根据某个参数来获取对应的实现类。</li><li>多个并发多线程使用ServiceLoader类的实例是不安全的。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://time.geekbang.org/column/intro/82?code=w8EZ6RGOQApZJ5tpAzP8dRzeVHxZ4q%2FfOdSbSZzbkhc%3D" target="_blank" rel="noopener">Java核心技术36讲</a><br><a href="https://docs.oracle.com/javase/tutorial/ext/basics/spi.html" target="_blank" rel="noopener">The Java™ Tutorials</a><br><a href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html" target="_blank" rel="noopener">Java Doc</a><br><a href="https://www.developer.com/java/article.php/3848881/Service-Provider-Interface-Creating-Extensible-Java-Applications.htm" target="_blank" rel="noopener">Service Provider Interface: Creating Extensible Java Applications</a><br><a href="https://en.wikipedia.org/wiki/Service_provider_interface" target="_blank" rel="noopener">Service provider interface</a><br><a href="https://www.cnblogs.com/lovesqcc/p/5229353.html" target="_blank" rel="noopener">Java ServiceLoader使用和解析</a><br><a href="https://blog.csdn.net/yangguosb/article/details/78772730" target="_blank" rel="noopener">Java基础之SPI机制</a><br><a href="https://cxis.me/2017/04/17/Java%E4%B8%ADSPI%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">Java中SPI机制深入及源码解析</a><br><a href="http://www.spring4all.com/article/260" target="_blank" rel="noopener">SPI机制简介</a></p><p>都看到这里了，关注个公众号吧，一起交流学习<br><img src="/images/%E7%90%86%E8%A7%A3Java%E4%B8%ADSPI%E6%9C%BA%E5%88%B6/2.jpg" alt="caison_way"></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-结构型模式</title>
      <link href="/2019/10/13/she-ji-mo-shi-jie-gou-xing-mo-shi/"/>
      <url>/2019/10/13/she-ji-mo-shi-jie-gou-xing-mo-shi/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/0.jpg" alt></p><h1 id="享元模式-Flyweight"><a href="#享元模式-Flyweight" class="headerlink" title="享元模式(Flyweight)"></a>享元模式(Flyweight)</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/1.png" alt="享元模式"><br><strong>意图：</strong>运用共享技术有效地支持大量细粒度的对象。<br><strong>主要解决：</strong>在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。</p><h1 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式(Proxy)"></a>代理模式(Proxy)</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/2.png" alt="代理模式"><strong>意图：</strong>为其他对象提供一种代理以控制对这个对象的访问。<br><strong>主要解决：</strong>在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。</p><h1 id="桥接模式-Bridge"><a href="#桥接模式-Bridge" class="headerlink" title="桥接模式(Bridge)"></a>桥接模式(Bridge)</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/3.png" alt="桥接模式"><strong>意图：</strong>将抽象部分与实现部分分离，使它们都可以独立的变化。<br><strong>主要解决：</strong>在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活</p><h1 id="组合模式-Composite"><a href="#组合模式-Composite" class="headerlink" title="组合模式(Composite)"></a>组合模式(Composite)</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/4.png" alt="组合模式"><strong>意图：</strong>将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。<br><strong>主要解决：</strong>它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。</p><h1 id="装饰器模式-Decorator"><a href="#装饰器模式-Decorator" class="headerlink" title="装饰器模式(Decorator)"></a>装饰器模式(Decorator)</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/5.png" alt="装饰器模式"><strong>意图：</strong>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。<br><strong>主要解决：</strong>一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</p><h1 id="适配器模式-Adapter"><a href="#适配器模式-Adapter" class="headerlink" title="适配器模式(Adapter)"></a>适配器模式(Adapter)</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/6.png" alt="适配器模式"><strong>意图：</strong>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br><strong>主要解决：</strong>主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。</p><h1 id="门面模式-Facade"><a href="#门面模式-Facade" class="headerlink" title="门面模式(Facade)"></a>门面模式(Facade)</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/7.png" alt="门面模式"><br><strong>意图：</strong>为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br><strong>主要解决：</strong>降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《阿里巴巴Java开发手册》学习笔记</title>
      <link href="/2019/10/13/a-li-ba-ba-java-kai-fa-shou-ce-xue-xi-bi-ji/"/>
      <url>/2019/10/13/a-li-ba-ba-java-kai-fa-shou-ce-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E3%80%8A%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0.jpg" alt></p><p>2017年，阿里官方推出一套<strong>Java编程规范</strong>：<a href="https://files.cnblogs.com/files/han-1034683568/阿里巴巴Java开发手册终极版v1.3.0.pdf" target="_blank" rel="noopener">《阿里巴巴Java开发手册(终极版)》</a>，这套Java统一规范标准将有助于提高行业编码规范化水平，帮助行业人员提高开发质量和效率、大大降低代码维护成本。推出之后，在CSDN，InfoQ，知乎等网站引起广泛讨论，口碑收获颇丰。本文旨在抛砖引玉，共同学习这套阿里巴巴近万名开发同学集体智慧的结晶写出来的编程规范。</p><h2 id="整体大纲"><a href="#整体大纲" class="headerlink" title="整体大纲"></a>整体大纲</h2><p><img src="/images/%E3%80%8A%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" alt="整体大纲"></p><p>相比起多年前Google的编程规范，阿里巴巴发布的Java开发手册之所以叫做<strong>”开发手册”</strong>，而不是像Google那样叫做“Style Guide(样式风格)”，是因为它不仅仅局限于<strong>样式风格</strong>这一方面，而是以开发者为中心视角，划分为<strong>编程规约、异常日志规约、MySQL规约、工程规约、安全规约</strong>五大块，再根据内容特征，细分成若干目录。根据约束力强弱和故障敏感性，规约依次分为强制、推荐、参考三大类。</p><p>该开发手册每一条都值得学习，这里只列出其中颇有感受的几点来共同学习一下。</p><h2 id="命名规约"><a href="#命名规约" class="headerlink" title="命名规约"></a>命名规约</h2><blockquote><p>【强制】 POJO 类中布尔类型的变量，都不要加 is ，否则部分框架解析会引起序列化错误。<br><strong>反例：</strong>定义为基本数据类型 boolean isSuccess;的属性，它的方法也是 isSuccess() ，RPC框架在反向解析的时候，“以为”对应的属性名称是 success ，导致属性获取不到，进而抛出异常。</p></blockquote><p>对于isSuccess这个布尔变量，IDE在自动生成getter,setter方法时，<strong>生成的方法名称是isSuccess和setSuccess，而不是isIsSuccess和setIsSuccess,</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DemoPOJO</span><span class="token punctuation">{</span>    <span class="token keyword">boolean</span> active<span class="token punctuation">;</span>    <span class="token keyword">boolean</span> isSuccess<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> active<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setActive</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> active<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>active <span class="token operator">=</span> active<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> isSuccess<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSuccess</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> success<span class="token punctuation">)</span> <span class="token punctuation">{</span>        isSuccess <span class="token operator">=</span> success<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>除了RPC框架反向解析会有问题，类型情况反向解析时也会有问题：<br>比如SpringMVC在接收前端页面传回一个”isSuccess”布尔变量时，解析成为POJO对象时，找不到setIsSuccess方法，导致POJO的属性不能正确获取，而且比较坑的是，这种情况不容易发现异常，最终解析后的属性值是拿到布尔类型默认值false。</p><h2 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h2><blockquote><p>【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。如：缓存相关的常量放在类： CacheConsts 下 ； 系统配置相关的常量放在类： ConfigConsts 下。<br><strong>说明：</strong>大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。</p></blockquote><p>在写代码的时候，从易用性和可维护性出发，不推荐一个类内容太多，大而全的类，改起来牵一发动全身，一个类只负责一类功能，不要涵盖太多方面。</p><h2 id="OOP规约"><a href="#OOP规约" class="headerlink" title="OOP规约"></a>OOP规约</h2><blockquote><p>【强制】所有的覆写方法，必须加@ Override 注解。<br><strong>反例：</strong> getObject() 与 get 0 bject() 的问题。一个是字母的 O ，一个是数字的 0，加@ Override可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。</p></blockquote><p>尽量用最安全的方式写代码，尽量让问题在<strong>编译期暴露</strong>，而不是运行期暴露</p><hr><blockquote><p>【强制】 Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals 。<br><strong>正例：</strong>“ test “ .equals(object);<br><strong>反例：</strong> object.equals( “ test “ );<br><strong>说明：</strong>推荐使用 java . util . Objects # equals （JDK 7 引入的工具类 ）</p></blockquote><p>类似的还有使用 “==”符号的时候，写成：<strong>if(100 == sum)</strong>比起写成：<strong>if(sum==100)</strong>，前者更好，因为这样可以避免不小心写成<strong>if(sum=100)</strong>的问题，前者会编译报错</p><hr><blockquote><p>【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。<br>说明：对于 Integer var =?在-128 至 127 之间的赋值， <strong>Integer 对象是在IntegerCache.cache 产生，会复用已有对象</strong>，这个区间内的 Integer 值可以直接使用==进行判断， 但是这个区间之外的所有数据， 都会在堆上产生， 并不会复用已有对象， 这是一个大坑，推荐使用 <strong>equals</strong> 方法进行判断。</p></blockquote><pre class=" language-java"><code class="language-java"> Integer integerA1 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> Integer integerA2 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>integerA1 <span class="token operator">==</span> integerA2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//true</span> Integer integerB1 <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span> Integer integerB2 <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>integerB1 <span class="token operator">==</span> integerB2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//false</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>integerB1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//true</span></code></pre><hr><blockquote><p>【强制】关于基本数据类型与包装数据类型的使用标准如下：<br>1 ） 所有的 POJO 类属性必须使用<strong>包装数据类型</strong>。<br>2 ） RPC 方法的返回值和参数必须使用<strong>包装数据类型</strong>。<br>3 ） 所有的局部变量【推荐】使用<strong>基本数据类型</strong>。<br>说明： POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE 问题，或者入库检查，都由<strong>使用者来保证</strong>。<br><strong>正例：</strong>数据库的查询结果可能是 null ，因为自动拆箱，用基本数据类型接收有 NPE 风险。<br><strong>反例：</strong>比如显示成交总额涨跌情况，即正负 x %， x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示：0%，这是不合理的，应该显示成中划线-。所以包装数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出。</p></blockquote><p>NPE问题：空指针异常(Null Pointer Exception)</p><hr><blockquote><p>【强制】定义 DO / DTO / VO 等 POJO 类时，不要设定任何属性<strong>默认值</strong>。<br><strong>反例：</strong> POJO 类的 createTime 默认值为 new Date(); 但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。</p></blockquote><hr><blockquote><p>【强制】 POJO 类必须写 toString 方法。使用 IDE 的中工具： <strong>source &gt; generate</strong> ，toString时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString 。<br><strong>说明：</strong>在方法执行抛出异常时，可以直接调用 POJO 的 toString() 方法打印其属性值，便于排查问题。</p></blockquote><hr><blockquote><p>【推荐】 类内方法定义顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt;  getter / setter方法。<br><strong>说明</strong>：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为方法信息价值较低，所有 Service 和 DAO 的 getter / setter 方法放在类体最后。</p></blockquote><hr><blockquote><p>【推荐】类成员与方法访问控制从严：<br>1 ） 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 <strong>private</strong> 。<br>2 ） 工具类不允许有 <strong>public</strong> 或 <strong>default</strong> 构造方法。<br>3 ） 类非 static 成员变量并且与子类共享，必须是 <strong>protected</strong> 。<br>4 ） 类非 static 成员变量并且仅在本类使用，必须是 <strong>private</strong> 。<br>5 ） 类 static 成员变量如果仅在本类使用，必须是 <strong>private</strong> 。<br>6 ） 若是 static 成员变量，必须考虑是否为 <strong>final</strong> 。<br>7 ） 类成员方法只供类内部调用，必须是 <strong>private</strong> 。<br>8 ） 类成员方法只对继承类公开，那么限制为 <strong>protected</strong> 。<br><strong>说明</strong>：任何类、方法、参数、变量，严控访问范围。过宽泛的访问范围，不利于模块解耦。思考：如果是一个 private 的方法，想删除就删除，可是一个 public 的 Service 方法，或者一个 public 的成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，如果无限制的到处跑，那么你会担心的。</p></blockquote><p>1）将构造方法私有化，一般在单例模式下用得比较多，这时使用<strong>getInstance()</strong>方法来获取一个实例对象。<br>2）工具类的话，应该暴露出来的方法是静态方法，使用者静态调用，不必实例化对象。<br>严格控制访问范围，也可以避免属性值被不小心乱改。</p><h2 id="集合处理"><a href="#集合处理" class="headerlink" title="集合处理"></a>集合处理</h2><blockquote><p>【强制】关于 hashCode 和 equals 的处理，遵循如下规则：<br>1） 只要重写 <strong>equals</strong> ，就必须重写 <strong>hashCode</strong> 。<br>2） 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写这两个方法。<br>3） 如果自定义对象做为 Map 的键，那么必须重写 hashCode 和 equals 。<br><strong>正例：</strong> String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象作为 key 来使用。</p></blockquote><p>假如类User重写了“equals”，没有重写“hashCode”方法，现在有<strong>userA</strong>和<strong>userB</strong> 2个对象，它们用equals比较时为true,2个对象存入一个Set集合中，Set调用User类默认的hashCode方法，结果在集合中就保存了2个User对象而不是我们想象中的一个    User对象</p><p>关于快速重写hashCode,有许多方法：</p><blockquote><ul><li>Google的Guava项目里有处理hashCode()和equals()的工具类</li><li>com.google.common.base.ObjectsApache Commons也有类似的工具类EqualsBuilder和HashCodeBuilder</li><li>Java 7 也提供了工具类java.util.Objects</li><li>常用IDE都提供hashCode()和equals()的代码生成。<br>(<a href="https://www.zhihu.com/question/28293143/answer/40237535" target="_blank" rel="noopener">来源:知乎</a>)</li></ul></blockquote><hr><blockquote><p>【强制】  ArrayList 的 subList 结果不可强转成 ArrayList ， 否则会抛出 ClassCastException异常： java . util . RandomAccessSubList cannot be cast to java . util . ArrayList ;<br><strong>说明：</strong> subList 返回的是  ArrayList 的内部类  SubList ，并不是  ArrayList ，<strong>而是ArrayList 的一个视图</strong>，对于 SubList 子列表的所有操作最终会反映到原列表上。</p></blockquote><blockquote><p>【强制】 在 subList 场景中，高度注意对原集合元素个数的修改，<strong>会导致子列表的遍历、增加、删除</strong>均产生 ConcurrentModificationException 异常。</p></blockquote><blockquote><p>【强制】使用工具类 Arrays . asList() 把数组转换成集合时，不能使用其修改集合相关的方法，它的 add / remove / clear 方法会抛出UnsupportedOperationException 异常。<br><strong>说明：</strong> asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。 Arrays . asList体现的是<strong>适配器模式</strong>，只是转换接口，后台的数据仍是数组。<br>String[] str = new String[] { “a”, “b” };<br>List list = Arrays.asList(str);<br>第一种情况： list.add(“c”);  运行时<strong>异常</strong>。<br>第二种情况： str[0]= “gujin”; 那么 list.get(0) 也会随之修改</p></blockquote><p>类似问题，可以使用<strong>FindBugs</strong>插件，自动扫描代码中的Bug，这类问题这个插件是可以检测出来的，类似的在对象中<strong>返回属性域的一个引用</strong>时，对该引用的修改会影响原对象的域的。</p><hr><blockquote><p>【推荐】<strong>高度注意</strong> Map 类集合 K / V 能不能存储 null 值的情况，如下表格：</p></blockquote><blockquote><table><thead><tr><th align="left">集合类</th><th align="left">Key</th><th align="left">Value</th><th align="left">Super</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Hashtable</td><td align="left"><strong>不允许为null</strong></td><td align="left"><strong>不允许 null</strong></td><td align="left">Dictionary</td><td align="left">线程安全</td></tr><tr><td align="left">ConcurrentHashMap</td><td align="left"><strong>不允许为 null</strong></td><td align="left"><strong>不允许为 null</strong></td><td align="left">AbstractMap</td><td align="left">分段锁技术</td></tr><tr><td align="left">TreeMap</td><td align="left"><strong>不允许为null</strong></td><td align="left">允许为 null</td><td align="left">AbstractMap</td><td align="left">线程不安全</td></tr><tr><td align="left">HashMap</td><td align="left">允许为 null</td><td align="left">允许为 null</td><td align="left">AbstractMap</td><td align="left">线程不安全</td></tr><tr><td align="left"><strong>反例：</strong> 由于 HashMap 的干扰，很多人认为 ConcurrentHashMap 是可以置入 null 值，注意存储null 值时会抛出 <strong>NPE 异常</strong>。</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table></blockquote><hr><blockquote><p>【参考】利用 <strong>Set 元素唯一的特性</strong>，可以快速对一个集合进行去重操作，避免使用 List的contains 方法进行遍历、对比、去重操作。</p></blockquote><h2 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h2><blockquote><p>【强制】线程资源必须通过线程池提供，<strong>不允许在应用中自行显式创建线程</strong>。<br><strong>说明：</strong>使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p></blockquote><blockquote><p>【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。<br>说明： Executors 返回的线程池对象的弊端如下：<br><strong>1） FixedThreadPool 和 SingleThreadPool :</strong><br>允许的请求队列长度为 Integer.MAX_VALUE ，可能会堆积大量的请求，从而导致 OOM 。<br><strong>2） CachedThreadPool 和 ScheduledThreadPool :</strong><br>允许的创建线程数量为 Integer.MAX_VALUE ，可能会创建大量的线程，从而导致 OOM 。</p></blockquote><p>OOM - Out of Mana法力耗尽,系统资源耗尽。</p><blockquote><p><strong>《Effective java》第68条：executor和task优先于线程</strong><br>尽量不直接使用线程，现在关键的抽象不在是Thread，它已可是即充当工作单元，又是执行机制。现在工作单元和执行机制是分开的。</p></blockquote><p>也就是说，把任务(task)的定义和任务的通用执行机制分开，任务有2种，Runnable和Callable，执行机制通用的是executor service。这样做的好处就是下次其他地方需要执行任务就可以愉快复用了，在<strong>执行任务策略</strong>方面，也因此可以获得极大的灵活性，比如任务的取消，实现<strong>等待所有任务完成之后才执行下一</strong>步操作等策略。</p><hr><blockquote><p>【强制】 <strong>SimpleDateFormat 是线程不安全的类</strong>，一般不要定义为 static 变量，如果定义为<br>static ，必须加锁，或者使用 DateUtils 工具类。<br>正例：注意线程安全，使用 DateUtils 。亦推荐如下处理：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> ThreadLocal<span class="token operator">&lt;</span>DateFormat<span class="token operator">></span> df <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span>DateFormat<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> DateFormat <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>说明：如果是 JDK 8 的应用，可以使用 Instant 代替 Date， LocalDateTime 代替 Calendar，<strong>DateTimeFormatter 代替 Simpledateformatter</strong>，官方给出的解释： simple beautiful strong immutable thread - safe </p></blockquote><p>个人推荐的话，需要做日期与字符串的转换，推荐使用joda的<a href="http://joda-time.sourceforge.net/apidocs/org/joda/time/DateTime.html" target="_blank" rel="noopener">DataTime</a>,主要特点是易于使用，功能完整，可以利用它<strong>把JDK Date和Calendar类完全替换掉</strong>，而且仍然能够提供很好的集成。</p><hr><blockquote><p>【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的<strong>加锁顺序</strong>，否则可能会造成死锁。<br><strong>说明：</strong>线程一需要对表 A 、 B 、 C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 A 、 B 、 C ，否则可能出现死锁。</p></blockquote><p>死锁问题也可以考虑用<strong>对象锁技术</strong>来减少。</p><hr><blockquote><p>【强制】多线程并行处理定时任务时， Timer 运行多个 TimeTask 时，<strong>只要其中之一没有捕获抛出的异常</strong>，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。</p></blockquote><p>除了要注意捕获异常之外，使用Timer还要注意不要执行需要跑<strong>运行时间过长</strong>的任务，否则在一个定时周期内任务没跑完的会，会导致定时不准，因为一个Timer内部是<strong>单线程在跑所有的TimeTask</strong>。</p><hr><blockquote><p>【参考】 volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。如果是 count ++操作，使用如下类实现：</p><pre class=" language-java"><code class="language-java">AtomicInteger count <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>count<span class="token punctuation">.</span><span class="token function">addAndGet</span><span class="token punctuation">(</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre><p> 如果是 JDK 8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好 （ 减少乐观锁的重试次数 ） </p></blockquote><p>多个线程操作同一个对象就会有数据可见性问题，当A线程修改了变量number，修改完成之后，B线程读这个number变量，读到的变量不一定是A线程修改后的变量，什么时候B线程能读到A线程修改后的变量值？<strong>有可能永远都读不到</strong>，这种现象称为<strong>“重排序(Recordering)”</strong><br>要避免数据可见性的问题，最简单的方法是使用内置锁(synchronized)来保护变量，内置锁可以用于确保某个线程以一种<strong>可预测的方法来查看</strong>另一个线程的执行结果。也就是说，刚刚的number变量如果使用内置锁保护的话，可以保证多线程可见性。</p><hr><blockquote><p>【参考】  HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中注意规避此风险。</p></blockquote><p>HashMap容量不足内部会有一个扩容的操作，比较耗CPU，规避此问题可以在初始化HashMap的时候指定容器大小。</p><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><blockquote><p>【强制】在一个 switch 块内，每个 case 要么通过 break / return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止 ； 在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使它什么代码也没有。</p></blockquote><p>同样如果不小心忘记写break，FindBugs插件可以检测出来。</p><hr><blockquote><p>【推荐】推荐尽量少用 else ，  if - else 的方式可以改写成：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   <span class="token keyword">return</span> obj<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 接着写 else 的业务逻辑代码;</span></code></pre><p>说明：如果非得使用 if()…else if()…else… 方式表达逻辑，<strong>【强制】请勿超过 3 层</strong>，<br>超过请使用状态设计模式。<br><strong>正例：</strong>逻辑上超过 3 层的 if-else 代码可以使用卫语句，或者状态模式来实现。</p></blockquote><p>很多时候，例如做参数校验的时候，尽量避免不要用一堆 else if，那样导致读代码的人要把整个方法的代码都读完才能理解好代码，建议使用:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>conditionA<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   <span class="token keyword">return</span> <span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>conditionB<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   <span class="token keyword">return</span> <span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这样的单独检查就是<strong>卫语句(guard clauses)</strong>.卫语句可以把我们的视线从异常处理中解放出来，<strong>集中精力到正常处理</strong>的代码中。</p><hr><blockquote><p>【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个<strong>有意义的布尔变量名</strong>，以提高可读性。<br><strong>说明：</strong>很多 if 语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？<br><strong>正例：</strong><br>//伪代码如下<br>boolean existed = (file.open(fileName, “w”) != null) &amp;&amp; (…) || (…);<br>if (existed) {<br>…<br>}<br><strong>反例：</strong><br>if ((file.open(fileName, “w”) != null) &amp;&amp; (…) || (…)) {<br>…<br>}</p></blockquote><p>用一个有意义的布尔变量名，替代复杂逻辑判断的结果，这个变量名可以起到一个<strong>注释</strong>的作用。如果一个方法过长也是不优雅的，可以考虑重构拆分出几个短一点的私有方法来被调用，<strong>方法的名称就是一个很好的注释</strong>，即时方法只被调用一次这种重构也是有意义的。</p><hr><blockquote><p>【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 try - catch 操作（这个try - catch是否可以移至循环体外 ）。</p></blockquote><p>循环里面不要做耗时过长时间的事情，如果耗时过长，应该扔进去队列里面异步处理。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><blockquote><p>【强制】不要捕获 Java 类库中定义的继承自 RuntimeException 的运行时异常类，如：<br>IndexOutOfBoundsException / NullPointerException，这类异常由程序员预检查<br>来规避，保证程序健壮性。<br><strong>正例：</strong> if(obj != null) {…}<br><strong>反例：</strong> try { obj.method() } catch(NullPointerException e){…}</p></blockquote><blockquote><p>【推荐】定义时区分 unchecked /  checked 异常，避免直接使用 RuntimeException 抛出，<strong>更不允许抛出 Exception 或者 Throwable</strong> ，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如： DAOException /  ServiceException 等。</p></blockquote><p>对可恢复的情况使用受检异常，对编程错误使用运行时异常，建议优先使用标准的异常。</p><hr><blockquote><p>【强制】<strong>异常不要用来做流程控制</strong>，条件控制，因为异常的处理效率比条件分支低。</p></blockquote><p><strong>只针对异常的情况才使用异常</strong></p><hr><blockquote><p>【强制】<strong>对大段代码进行 try - catch</strong> ，这是不负责任的表现。 catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。</p></blockquote><p>把try块的范围限制到最小</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>[图片上传失败…(image-6100e-1522248360126)]<br>还有Mysql规约值得探究，篇幅所限制，这里就不展开了。</p><p>有位架构师曾经在知乎网分享了这样的<a href="https://www.zhihu.com/question/40514188/answer/93405793" target="_blank" rel="noopener">故事：</a><br>2013年stackoverflow第一次公布了部分数据和架构，当时stackoverflow日UV 300W+，PV 2Y+，他们使用了<strong>8台</strong>物理服务器，而这个架构师的公司使用了<strong>近500台</strong>物理服务器，换算到性能上，<strong>硬件资源对比是125:4,**</strong>性能差异是反比，8：250**。</p><p>  公司的架构上没有大问题，各项参数调优，<strong>缓存做了，db分布了，nginx mysql redis的各项参数，也做了性能测试和db test经过n轮调整</strong>，那为什么性能差异还是这么大？最后他总结出来：<br> 主要的业务逻辑开销更多性能是其次，主要的，<strong>是应用层面的程序员造成的：他们处理过许多典型的性能坑：</strong></p><ul><li>db查询没用到索引</li><li>联表查询太复杂性能奇差</li><li>循环里写查询一次连接变几十次</li><li>打开文件句柄 socket连接没有释放</li><li>300k文本直接存到redis里</li><li>curl请求没有加超时</li><li>不同的进程争抢同一个文件资源写日志</li><li>get_image_size()获取图片尺寸(<strong>会把图片文件整个读取到内存里，每个连接都会！</strong>)</li><li>写的扩展内存溢出</li><li>直接读取整个巨大文本文件(<strong>应该逐行方式读取</strong>)</li><li>在代码逻辑循环里直接发短信发邮件(<strong>应该扔到队列异步处理</strong>)</li><li>ip黑名单和关键词过滤直接用文本查找比对(*<em>应该做成hash表 *</em>)</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>理解Java的分级引用模型</title>
      <link href="/2019/10/13/li-jie-java-de-fen-ji-yin-yong-mo-xing/"/>
      <url>/2019/10/13/li-jie-java-de-fen-ji-yin-yong-mo-xing/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E7%90%86%E8%A7%A3Java%E7%9A%84%E5%88%86%E7%BA%A7%E5%BC%95%E7%94%A8%E6%A8%A1%E5%9E%8B/0.jpg" alt></p><pre><code>作者 陈彩华文章转载交流请联系 caison@aliyun.com</code></pre><p>本文通过探析Java中的引用模型，分析比较强引用、软引用、弱引用、虚引用的概念及使用场景，<strong>知其然且知其所以然</strong>，希望给大家在实际开发实践、学习开源项目提供参考。</p><h1 id="1-Java的引用"><a href="#1-Java的引用" class="headerlink" title="1 Java的引用"></a>1 Java的引用</h1><p>对于Java中的垃圾回收机制来说，对象是否被应该回收的取决于该对象是否被引用。因此，引用也是JVM进行内存管理的一个重要概念。Java中是JVM负责内存的分配和回收，这是它的优点（使用方便，程序不用再像使用C语言那样担心内存），但同时也是它的缺点（不够灵活）。由此，Java提供了引用分级模型，可以<strong>定义Java对象重要性和优先级，提高JVM内存回收的执行效率</strong>。</p><p>关于引用的定义，在JDK1.2之前，如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称为这块内存代表着一个引用；JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)四种。</p><p>软引用对象和弱应用对象主要用于：当内存空间还足够，则能保存在内存之中；如果内存空间在垃圾收集之后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的使用场景。</p><p>而虚引用对象用于替代不靠谱的finalize方法，可以获取对象的回收事件，来做资源清理工作。</p><h1 id="2-对象生命周期"><a href="#2-对象生命周期" class="headerlink" title="2 对象生命周期"></a>2 对象生命周期</h1><p>##　2.1 无分级引用对象生命周期<br>前面提到，分层引用的模型是用于内存回收，没有分级引用对象下，一个对象从创建到回收的生命周期可以简单地用下图概括：对象被创建，被使用，有资格被收集，最终被收集，阴影区域表示对象“强可达”时间：<br><img src="/images/%E7%90%86%E8%A7%A3Java%E7%9A%84%E5%88%86%E7%BA%A7%E5%BC%95%E7%94%A8%E6%A8%A1%E5%9E%8B/1.png" alt="对象生命周期(无分级引用)"></p><h2 id="2-2-有分级引用对象生命周期"><a href="#2-2-有分级引用对象生命周期" class="headerlink" title="2.2 有分级引用对象生命周期"></a>2.2 有分级引用对象生命周期</h2><p>JDK1.2引入java.lang.ref程序包之后，对象的生命周期多了3个阶段，软可达，弱可达，虚可达，这些状态仅适用于符合垃圾回收条件的对象，这些对象处于非强引用阶段，而且需要基于java.lang.ref包中的相关的引用对象类来指示标明。</p><ul><li><p>软可达<br>软可达对象用SoftReference来指示标明，并没有强引用，垃圾回收器会尽可能长时间地保留对象，但是会在抛出OutOfMemoryError异常之前收集它。</p></li><li><p>弱可达<br>弱可达对象用WeakReference来指示标明，并没有强引用或软引用，垃圾回收器会随时回收对象，并不会尝试保留它，但是会在抛出OutOfMemoryError异常之前收集它。</p></li></ul><p>假设垃圾收集器在某个时间点确定对象是弱可达的。 那时它将原子地清除该弱可达引用对象关联的对象。</p><ul><li>虚可达<br>虚可达对象用PhantomReference来指示标明，它已经被标记选中进行垃圾回收并且它的finalizer(如果有)已经运行。在这种情况下，术语“可达”实际上是用词不当，因为您无法访问实际对象。</li></ul><p><img src="/images/%E7%90%86%E8%A7%A3Java%E7%9A%84%E5%88%86%E7%BA%A7%E5%BC%95%E7%94%A8%E6%A8%A1%E5%9E%8B/2.png" alt="分级引用作用时间在对象生命周期中的位置"></p><p>对象生命周期图中出现三个新的可选状态会造成一些困惑。逻辑顺序上是从强可达到软，弱和虚，最终到回收，但实际的情况取决于程序创建的参考对象。但如果创建WeakReference但不创建SoftReference，则对象直接从强可达到弱到达最终到收集。</p><h1 id="3-强引用"><a href="#3-强引用" class="headerlink" title="3 强引用"></a>3 强引用</h1><p>　　强引用就是指在程序代码之中普遍存在的，比如下面这段代码中的obj和str都是强引用：</p><pre class=" language-java"><code class="language-java">Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String str <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span></code></pre><p>只要强引用还存在，垃圾收集器永远不会回收被引用的对象，即使在内存不足的情况下，JVM即使抛出OutOfMemoryError异常也不会回收这种对象。</p><p>实际使用上，可以通过把引用显示赋值为null来中断对象与强引用之前的关联，如果没有任何引用执行对象，垃圾收集器将在合适的时间回收对象。</p><p>例如ArrayList类的remove方法中就是通过将引用赋值为null来实现清理工作的：</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * Removes the element at the specified position in this list.     * Shifts any subsequent elements to the left (subtracts one from their     * indices).     *     * @param index the index of the element to be removed     * @return the element that was removed from the list     * @throws IndexOutOfBoundsException {@inheritDoc}     */</span>    <span class="token keyword">public</span> E <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        E oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span>                             numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// clear to let GC do its work</span>        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h1 id="4-引用对象"><a href="#4-引用对象" class="headerlink" title="4 引用对象"></a>4 引用对象</h1><p>介绍软引用、弱引用和虚引用之前，有必要介绍一下引用对象，<br>引用对象是程序代码和其他对象之间的间接层，称为引用对象。每个引用对象都围绕对象的引用构造，并且不能更改引用值。</p><p><img src="/images/%E7%90%86%E8%A7%A3Java%E7%9A%84%E5%88%86%E7%BA%A7%E5%BC%95%E7%94%A8%E6%A8%A1%E5%9E%8B/3.png" alt><br>引用对象提供get()来获得其引用值的一个强引用，垃圾收集器可能随时回收引用值所指的对象。<br>一旦对象被回收，get()方法将返回null，要正确使用引用对象，下面使用SoftReference(软引用对象)作为参考示例：</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 简单使用demo     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">simpleUseDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> myList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        SoftReference<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> refObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>myList<span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> refObj<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 整个列表已经被垃圾回收了，做其他处理</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>也就是说，使用时：</p><ul><li><p>1、必须经常检查引用值是否为null<br>垃圾收集器可能随时回收引用对象，如果轻率地使用引用值，迟早会得到一个NullPointerException。</p></li><li><p>2、必须使用强引用来指向引用对象返回的值<br>垃圾收集器可能在任何时间回收引用对象，即使在一个表达式中间。</p><pre class=" language-java"><code class="language-java">  <span class="token comment" spellcheck="true">/**   * 正确使用引用对象demo   */</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">trueUseRefObjDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      List<span class="token operator">&lt;</span>String<span class="token operator">></span> myList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      SoftReference<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> refObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>myList<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 正确的使用，使用强引用指向对象保证获得对象之后不会被回收</span>      List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> refObj<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>          list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 整个列表已经被垃圾回收了，做其他处理</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/**   * 错误使用引用对象demo   */</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">falseUseRefObjDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      List<span class="token operator">&lt;</span>String<span class="token operator">></span> myList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      SoftReference<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> refObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>myList<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// XXX 错误的使用，在检查对象非空到使用对象期间，对象可能已经被回收</span>      <span class="token comment" spellcheck="true">// 可能出现空指针异常</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> refObj<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          refObj<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre></li><li><p>3、必须持有引用对象的强引用<br>如果创建引用对象，没有持有对象的强引用，那么引用对象本身将被垃圾收集器回收。</p></li><li><p>4、当引用值没有被其他强引用指向时，软引用、弱引用和虚引用才会发挥作用，引用对象的存在就是为了方便追踪并高效垃圾回收。</p></li></ul><h1 id="5-软引用、弱引用和虚引用"><a href="#5-软引用、弱引用和虚引用" class="headerlink" title="5 软引用、弱引用和虚引用"></a>5 软引用、弱引用和虚引用</h1><p>引用对象的3个重要实现类位于java.lang.ref包下，分别是软引用SoftReference、弱引用WeakReference和虚引用PhantomReference。</p><h2 id="5-1-软引用"><a href="#5-1-软引用" class="headerlink" title="5.1 软引用"></a>5.1 软引用</h2><p>软引用用来描述一些还有用但非必需的对象。对于软引用关联着的对象，在系统将要发生抛出OutOfMemoryError异常之前，将会把这些对象列入回收范围之内进行第二次回收。如果这次回收还没有足够的内存，才会抛出OutOfMemoryError异常。在JDK1.2之后，提供了SoftReference类来实现软引用。</p><p>下面是一个使用示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ref<span class="token punctuation">.</span>SoftReference<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SoftRefDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SoftReference<span class="token operator">&lt;</span>String<span class="token operator">></span> sr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello world "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// hello world</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>JDK文档中提到：软引用适用于对内存敏感的缓存：每个缓存对象都是通过访问的 SoftReference，如果JVM决定需要内存空间，那么它将清除回收部分或全部软引用对应的对象。如果它不需要空间，则SoftReference指示对象保留在堆中，并且可以通过程序代码访问。在这种情况下，当它们被积极使用时，它们被强引用，否则会被软引用。如果清除了软引用，则需要刷新缓存。</p><p>实际使用上，要除非缓存的对象非常大，每个数量级为几千字节，才值得考虑使用软引用对象。例如：实现一个文件服务器，它需要定期检索相同的文件，或者需要缓存大型对象图。如果对象很小，必须清除很多对象才能产生影响，那么不建议使用，因为清除软引用对象会增加整个过程的开销。</p><h2 id="5-2-弱引用"><a href="#5-2-弱引用" class="headerlink" title="5.2 弱引用"></a>5.2 弱引用</h2><p>弱引用也是用来描述非必需对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发送之前。<strong>当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</strong>。</p><p>在JDK1.2之后，提供了WeakReference类来实现弱引用。</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 简单使用弱引用demo     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">simpleUseWeakRefDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        WeakReference<span class="token operator">&lt;</span>String<span class="token operator">></span> sr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello world "</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// before gc -> hello world </span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before gc -> "</span> <span class="token operator">+</span> sr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 通知JVM的gc进行垃圾回收</span>        System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// after gc -> null</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after gc -> "</span> <span class="token operator">+</span> sr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>可以看到被弱引用关联的对象，在gc之后被回收掉。<br>有意思的地方是，如果把上面代码中的：</p><pre class=" language-java"><code class="language-java">WeakReference<span class="token operator">&lt;</span>String<span class="token operator">></span> sr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello world "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>改为</p><pre class=" language-java"><code class="language-java">WeakReference<span class="token operator">&lt;</span>String<span class="token operator">></span> sr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"hello world "</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>程序将输出</p><pre><code>before gc -&gt; hello world after gc -&gt; hello world </code></pre><p>这是因为使用Java的String直接赋值和使用new区别在于：</p><ul><li>new 会在堆区创建一个可以被正常回收的对象。</li><li>String直接赋值，例如：String  str = String( “Hello”);<br>JVM首先在string池内里面看找不找到字符串 “Hello”，找到，不做任何事情；<br>否则，创建新的String对象，放到String常量池里面(常量池Hotspot1.7之前存于永生代，Hotspot1.7和1.7之后的版本存于堆区，通常不会被gc回收)。同时，由于遇到了new，还会在内存上（不是String常量池里面）创建String对象存储 “Hello”，并将内存上的（不是String池内的）String对象返回给str。</li></ul><p><strong>WeakHashMap</strong><br>为了更方便使用弱引用，Java还提供了WeakHashMap，功能类似HashMap，内部实现是用弱引用对key进行包装，当某个key对象没有任何强引用指向，gc会自动回收key和value对象。</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     *  weakHashMap使用demo     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">weakHashMapDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        WeakHashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span> weakHashMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String key1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"key1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String key2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"key2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String key3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"key3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        weakHashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key1<span class="token punctuation">,</span> <span class="token string">"value1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        weakHashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key2<span class="token punctuation">,</span> <span class="token string">"value2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        weakHashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key3<span class="token punctuation">,</span> <span class="token string">"value3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 使没有任何强引用指向key1</span>        key1 <span class="token operator">=</span> null<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before gc weakHashMap = "</span> <span class="token operator">+</span> weakHashMap <span class="token operator">+</span> <span class="token string">" , size="</span> <span class="token operator">+</span> weakHashMap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 通知JVM的gc进行垃圾回收</span>        System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after gc weakHashMap = "</span> <span class="token operator">+</span> weakHashMap <span class="token operator">+</span> <span class="token string">" , size="</span><span class="token operator">+</span> weakHashMap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>程序输出：</p><pre class=" language-java"><code class="language-java">before<span class="token operator">:</span> gc weakHashMap <span class="token operator">=</span> <span class="token punctuation">{</span>key1<span class="token operator">=</span>value1<span class="token punctuation">,</span> key2<span class="token operator">=</span>value2<span class="token punctuation">,</span> key3<span class="token operator">=</span>value3<span class="token punctuation">}</span> <span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">3</span>after<span class="token operator">:</span> gc weakHashMap <span class="token operator">=</span> <span class="token punctuation">{</span>key2<span class="token operator">=</span>value2<span class="token punctuation">,</span> key3<span class="token operator">=</span>value3<span class="token punctuation">}</span> <span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">2</span></code></pre><p>WeakHashMap比较适用于缓存的场景，例如Tomcat的缓存就用到。</p><h2 id="5-3-引用队列"><a href="#5-3-引用队列" class="headerlink" title="5.3  引用队列"></a>5.3  引用队列</h2><p>介绍虚引用之前，先介绍引用队列：<br>在使用引用对象时，通过判断get()方法返回的值是否为null来判断对象是否已经被回收，当这样做并不是非常高效，特别是当我们有很多引用对象，如果想找出哪些对象已经被回收，需要遍历所有所有对象。</p><p>更好的方案是使用引用队列，在构造引用对象时与队列关联，当gc（垃圾回收线程）准备回收一个对象时，如果发现它还仅有软引用(或弱引用，或虚引用)指向它，就会在回收该对象之前，把这个软引用（或弱引用，或虚引用）加入到与之关联的引用队列（ReferenceQueue）中。</p><p><strong>如果一个软引用（或弱引用，或虚引用）对象本身在引用队列中，就说明该引用对象所指向的对象被回收了</strong>，所以要找出所有被回收的对象，只需要遍历引用队列。</p><p>当软引用（或弱引用，或虚引用）对象所指向的对象被回收了，那么这个引用对象本身就没有价值了，如果程序中存在大量的这类对象（注意，我们创建的软引用、弱引用、虚引用对象本身是个强引用，不会自动被gc回收），就会浪费内存。因此我们这就可以手动回收位于引用队列中的引用对象本身。</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 引用队列demo     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">refQueueDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ReferenceQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> refQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 用于检查引用队列中的引用值被回收</span>        Thread checkRefQueueThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Reference<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">String</span><span class="token operator">></span> clearRef <span class="token operator">=</span> refQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> clearRef<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out                            <span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"引用对象被回收, ref = "</span> <span class="token operator">+</span> clearRef <span class="token operator">+</span> <span class="token string">", value = "</span> <span class="token operator">+</span> clearRef<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        checkRefQueueThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        WeakReference<span class="token operator">&lt;</span>String<span class="token operator">></span> weakRef1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"value1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> refQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>        WeakReference<span class="token operator">&lt;</span>String<span class="token operator">></span> weakRef2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"value2"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> refQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>        WeakReference<span class="token operator">&lt;</span>String<span class="token operator">></span> weakRef3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"value3"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> refQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ref1 value = "</span> <span class="token operator">+</span> weakRef1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", ref2 value = "</span> <span class="token operator">+</span> weakRef2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token operator">+</span> <span class="token string">", ref3 value = "</span> <span class="token operator">+</span> weakRef3<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始通知JVM的gc进行垃圾回收"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 通知JVM的gc进行垃圾回收</span>        System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>程序输出：</p><pre class=" language-java"><code class="language-java">ref1 value <span class="token operator">=</span> value1<span class="token punctuation">,</span> ref2 value <span class="token operator">=</span> value2<span class="token punctuation">,</span> ref3 value <span class="token operator">=</span> value3开始通知JVM的gc进行垃圾回收引用对象被回收<span class="token punctuation">,</span> ref <span class="token operator">=</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ref<span class="token punctuation">.</span>WeakReference<span class="token annotation punctuation">@48c6cd96</span><span class="token punctuation">,</span> value<span class="token operator">=</span>null引用对象被回收<span class="token punctuation">,</span> ref <span class="token operator">=</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ref<span class="token punctuation">.</span>WeakReference<span class="token annotation punctuation">@46013afe</span><span class="token punctuation">,</span> value<span class="token operator">=</span>null引用对象被回收<span class="token punctuation">,</span> ref <span class="token operator">=</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ref<span class="token punctuation">.</span>WeakReference<span class="token annotation punctuation">@423ea6e6</span><span class="token punctuation">,</span> value<span class="token operator">=</span>null</code></pre><h2 id="5-4-虚引用"><a href="#5-4-虚引用" class="headerlink" title="5.4 虚引用"></a>5.4 虚引用</h2><p>虚引用也称为幽灵引用或者幻影引用，不同于软引用和弱引用，虚引用不用于访问引用对象所指示的对象，相反，<strong>通过不断轮询虚引用对象关联的引用队列，可以得到对象回收事件</strong>。一个对象是否有虚引用的存在，完全不会对其生产时间构成影响，也无法通过虚引用来取得一个对象实例。虽然这看起来毫无意义，但它实际上可以用来做对象回收时<strong>资源清理、释放</strong>，它比finalize更灵活，我们可以基于虚引用做更安全可靠的对象关联的资源回收。</p><ul><li>finalize的问题<ul><li>Java语言规范并不保证finalize方法会被及时地执行、而且根本不会保证它们会被执行<br>如果可用内存没有被耗尽，垃圾收集器不会运行，finalize方法也不会被执行。</li><li>性能问题<br>JVM通常在单独的低优先级线程中完成finalize的执行。</li><li>对象再生问题<br>finalize方法中，可将待回收对象赋值给GC Roots可达的对象引用，从而达到对象再生的目的。</li></ul></li></ul><p>针对不靠谱finalize方法，完全可以使用虚引用来实现。在JDK1.2之后，提供了PhantomReference类来实现虚引用。</p><p>下面是简单的使用例子，通过访问引用队列可以得到对象的回收事件：</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 简单使用虚引用demo     * 虚引用在实现一个对象被回收之前必须做清理操作是很有用的,比finalize()方法更灵活     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">simpleUsePhantomRefDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ReferenceQueue<span class="token operator">&lt;</span>Object<span class="token operator">></span> refQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        PhantomReference<span class="token operator">&lt;</span>Object<span class="token operator">></span> phantomRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> refQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// null</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>phantomRef<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// null</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>refQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        obj <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 通知JVM的gc进行垃圾回收</span>        System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// null, 调用phantomRef.get()不管在什么情况下会一直返回null</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>phantomRef<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 当GC发现了虚引用，GC会将phantomRef插入进我们之前创建时传入的refQueue队列</span>        <span class="token comment" spellcheck="true">// 注意，此时phantomRef对象，并没有被GC回收，在我们显式地调用refQueue.poll返回phantomRef之后</span>        <span class="token comment" spellcheck="true">// 当GC第二次发现虚引用，而此时JVM将phantomRef插入到refQueue会插入失败，此时GC才会对phantomRef对象进行回收</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Reference<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> pollObj <span class="token operator">=</span> refQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// java.lang.ref.PhantomReference@1540e19d</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pollObj<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> pollObj<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 进行资源回收的操作</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>比较常见的，可以基于虚引用实现JDBC连接池，锁的释放等场景。<br>以连接池为例，调用方正常情况下使用完连接，需要把连接释放回池中，但是不可避免有可能程序有bug，造成连接没有正常释放回池中。基于虚引用对Connection对象进行包装，并关联引用队列，就可以通过轮询引用队列检查哪些连接对象已经被GC回收，释放相关连接资源。<a href="https://github.com/caison/caison-blog-demo" target="_blank" rel="noopener">具体实现已上传github的caison-blog-demo仓库</a>。</p><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h1><p>对比一下几种引用对象的不同：<br>|引用类型 | GC回收时间 |常见用途|生存时间|<br>| :- | :-: | :-:|  :-:|<br>|强引用|永不|对象的一般状态|JVM停止运行时|<br>|软引用|内存不足时|对象缓存|内存不足时终止|<br>|弱引用|GC时|对象缓存|GC后终止|</p><p>虚引用，配合引用队列使用，通过不断轮询引用队列获取对象回收事件。</p><p>虽然引用对象是一个非常有用的工具来管理你的内存消耗，但有时它们是不够的，或者是过度设计的 。例如，使用一个Map来缓存从数据库中读取的数据。虽然可以使用弱引用来作为缓存，但最终程序需要运行一定量的内存。如果不能给它足够实际足够的资源完成任何工作，那么错误恢复机制有多强大也没有用。</p><p>当遇到OutOfMemoryError错误，第一反应是要弄清楚它为什么会发生，也许真的是程序有bug，也许是可用内存设置的太低。</p><p>在开发过程中，应该制定程序具体的使用内存大小，而已要关注实际使用中用了多少内存。大多数应用程序在实际运行负载下，程序的内存占用会达到稳定状态，可以用此来作为参考来设置合理的堆大小。如果程序的内存使用量随着时间的推移而上升，很有可能是因为当对象不再使用时仍然拥有对对象的强引用。引用对象在这里可能会有所帮助，但更有可能是把它当做一个bug来进行修复。</p><p>文章所有涉及源码已经上传github，地址：<a href="https://github.com/caison/caison-blog-demo" target="_blank" rel="noopener">https://github.com/caison/caison-blog-demo</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/farmerjohngit/myblog/issues/10" target="_blank" rel="noopener">Java引用类型原理剖析</a></p><p><a href="http://www.kdgregory.com/index.php?page=java.refobj" target="_blank" rel="noopener">Java Reference Objects</a></p><p>《深入理解Java虚拟机——JVM高级特性与最佳实践(第2版)》</p><p><a href="https://time.geekbang.org/column/intro/82?code=w8EZ6RGOQApZJ5tpAzP8dRzeVHxZ4q%2FfOdSbSZzbkhc%3D" target="_blank" rel="noopener">Java核心技术36讲</a></p><p><a href="https://time.geekbang.org/column/intro/108?code=XamkmJYooKBPKe8hT7otClsFDeVHb6rptMYHTdgiRPU%3D" target="_blank" rel="noopener">深入拆解 Java 虚拟机</a></p><p> <a href="https://www.cnblogs.com/dolphin0520/p/3784171.html" target="_blank" rel="noopener">Java 如何有效地避免OOM：善于利用软引用和弱引用</a></p><p><a href="https://blog.csdn.net/imzoer/article/details/8044900" target="_blank" rel="noopener">Java幽灵引用的作用</a></p><p><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/ref/package-summary.html#package_description" target="_blank" rel="noopener">oracle官方文档</a></p><p>都看到这里了，关注个公众号吧，一起交流学习<br><img src="/images/%E7%90%86%E8%A7%A3Java%E7%9A%84%E5%88%86%E7%BA%A7%E5%BC%95%E7%94%A8%E6%A8%A1%E5%9E%8B/4.jpg" alt="caison_way"></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>理解Java-GC原理和调优</title>
      <link href="/2019/10/13/li-jie-java-gc-yuan-li-he-diao-you/"/>
      <url>/2019/10/13/li-jie-java-gc-yuan-li-he-diao-you/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E7%90%86%E8%A7%A3Java-GC%E5%8E%9F%E7%90%86%E5%92%8C%E8%B0%83%E4%BC%98/0.jpg" alt><br>文章首发于51CTO公众号</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文介绍GC基础原理和理论，GC调优方法思路和方法，基于Hotspot jdk1.8，学习之后将了解如何对生产系统出现的GC问题进行排查解决</p><p>阅读时长约30分钟，内容主要如下：</p><ul><li>GC基础原理，涉及调优目标，GC事件分类、JVM内存分配策略、GC日志分析等</li><li>CMS原理及调优</li><li>G1原理及调优</li><li>GC问题排查和解决思路</li></ul><h1 id="GC基础原理"><a href="#GC基础原理" class="headerlink" title="GC基础原理"></a>GC基础原理</h1><h2 id="1-GC调优目标"><a href="#1-GC调优目标" class="headerlink" title="1 GC调优目标"></a>1 GC调优目标</h2><p>大多数情况下对 Java 程序进行GC调优, 主要关注两个目标：响应速度、吞吐量</p><ul><li><p><strong>响应速度(Responsiveness)</strong><br>响应速度指程序或系统对一个请求的响应有多迅速。比如，用户订单查询响应时间，对响应速度要求很高的系统，较大的停顿时间是不可接受的。调优的重点是在短的时间内快速响应</p></li><li><p><strong>吞吐量(Throughput)</strong><br>吞吐量关注在一个特定时间段内应用系统的最大工作量，例如每小时批处理系统能完成的任务数量，在吞吐量方面优化的系统，较长的GC停顿时间也是可以接受的，因为高吞吐量应用更关心的是如何尽可能快地完成整个任务，不考虑快速响应用户请求</p></li></ul><p>GC调优中，GC导致的应用暂停时间影响系统响应速度，GC处理线程的CPU使用率影响系统吞吐量</p><h2 id="2-GC分代收集算法"><a href="#2-GC分代收集算法" class="headerlink" title="2 GC分代收集算法"></a>2 GC分代收集算法</h2><p>现代的垃圾收集器基本都是采用分代收集算法，其主要思想：<br>将Java的堆内存逻辑上分成两块：新生代、老年代，针对不同存活周期、不同大小的对象采取不同的垃圾回收策略</p><p><img src="/images/%E7%90%86%E8%A7%A3Java-GC%E5%8E%9F%E7%90%86%E5%92%8C%E8%B0%83%E4%BC%98/1.png" alt="分代收集算法"></p><ul><li>新生代（Young Generation）</li></ul><p>新生代又叫年轻代，大多数对象在新生代中被创建，很多对象的生命周期很短。每次新生代的垃圾回收（又称Young GC、Minor GC、YGC）后只有少量对象存活，所以使用复制算法，只需少量的复制操作成本就可以完成回收</p><p>新生代内又分三个区：一个Eden区，两个Survivor区(S0、S1，又称From Survivor、To Survivor)，大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到两个Survivor区（中的一个）。当这个Survivor区满时，此区的存活且不满足晋升到老年代条件的对象将被复制到另外一个Survivor区。对象每经历一次复制，年龄加1，达到晋升年龄阈值后，转移到老年代</p><ul><li>老年代（Old Generation）</li></ul><p>在新生代中经历了N次垃圾回收后仍然存活的对象，就会被放到老年代，该区域中对象存活率高。老年代的垃圾回收通常使用“标记-整理”算法</p><h2 id="3-GC事件分类"><a href="#3-GC事件分类" class="headerlink" title="3 GC事件分类"></a>3 GC事件分类</h2><p>根据垃圾收集回收的区域不同，垃圾收集主要通常分为Young GC、Old GC、Full GC、Mixed GC</p><h3 id="1-Young-GC"><a href="#1-Young-GC" class="headerlink" title="(1) Young GC"></a>(1) Young GC</h3><p>新生代内存的垃圾收集事件称为Young GC(又称Minor GC)，当JVM无法为新对象分配在新生代内存空间时总会触发 Young GC，比如 Eden 区占满时。新对象分配频率越高, Young GC 的频率就越高</p><p>Young GC 每次都会引起全线停顿(Stop-The-World)，暂停所有的应用线程，停顿时间相对老年代GC的造成的停顿，几乎可以忽略不计</p><h3 id="2-Old-GC-、Full-GC、Mixed-GC"><a href="#2-Old-GC-、Full-GC、Mixed-GC" class="headerlink" title="(2) Old GC 、Full GC、Mixed GC"></a>(2) Old GC 、Full GC、Mixed GC</h3><p><strong>Old GC</strong>，只清理老年代空间的GC事件，只有CMS的并发收集是这个模式<br><strong>Full GC</strong>，清理整个堆的GC事件，包括新生代、老年代、元空间等</p><ul><li><strong>Mixed GC</strong>，清理整个新生代以及部分老年代的GC，只有G1有这个模式</li></ul><h2 id="4-GC日志分析"><a href="#4-GC日志分析" class="headerlink" title="4 GC日志分析"></a>4 GC日志分析</h2><p>GC日志是一个很重要的工具，它准确记录了每一次的GC的执行时间和执行结果，通过分析GC日志可以调优堆设置和GC设置，或者改进应用程序的对象分配模式，开启的JVM启动参数如下：</p><pre><code>-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps  -XX:+PrintGCTimeStamps</code></pre><p>常见的Young GC、Full GC日志含义如下：</p><p><img src="/images/%E7%90%86%E8%A7%A3Java-GC%E5%8E%9F%E7%90%86%E5%92%8C%E8%B0%83%E4%BC%98/2.png" alt="Young GC"><br><img src="/images/%E7%90%86%E8%A7%A3Java-GC%E5%8E%9F%E7%90%86%E5%92%8C%E8%B0%83%E4%BC%98/3.png" alt="Full GC"></p><p>免费的GC日志图形分析工具推荐下面2个：</p><ul><li><a href="[https://github.com/chewiebug/GCViewer](https://github.com/chewiebug/GCViewer)">GCViewer</a>，下载jar包直接运行</li><li><a href="https://gceasy.io/" target="_blank" rel="noopener">gceasy</a>，web工具，上传GC日志在线使用</li></ul><h2 id="5-内存分配策略"><a href="#5-内存分配策略" class="headerlink" title="5 内存分配策略"></a>5 内存分配策略</h2><p>Java提供的自动内存管理，可以归结为解决了对象的内存分配和回收的问题，前面已经介绍了内存回收，下面介绍几条最普遍的内存分配策略</p><ul><li><p><strong>对象优先在Eden区分配</strong><br>大多数情况下，对象在先新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Young GC</p></li><li><p><strong>大对象之间进入老年代</strong><br>JVM提供了一个对象大小阈值参数(-XX:PretenureSizeThreshold，默认值为0，代表不管多大都是先在Eden中分配内存)，大于参数设置的阈值值的对象直接在老年代分配，这样可以避免对象在Eden及两个Survivor直接发生大内存复制</p></li><li><p><strong>长期存活的对象将进入老年代</strong><br>对象每经历一次垃圾回收，且没被回收掉，它的年龄就增加1，大于年龄阈值参数(-XX:MaxTenuringThreshold，默认15)的对象，将晋升到老年代中</p></li><li><p><strong>空间分配担保</strong><br>当进行Young GC之前，JVM需要预估：老年代是否能够容纳Young GC后新生代晋升到老年代的存活对象，以确定是否需要提前触发GC回收老年代空间，基于空间分配担保策略来计算：</p></li></ul><p><strong>continueSize：老年代最大可用连续空间</strong></p><p><img src="/images/%E7%90%86%E8%A7%A3Java-GC%E5%8E%9F%E7%90%86%E5%92%8C%E8%B0%83%E4%BC%98/4.png" alt="空间分配担保"></p><p>Young GC之后如果成功(Young GC后晋升对象能放入老年代)，则代表担保成功，不用再进行Full GC，提高性能；如果失败，则会出现“promotion failed”错误，代表担保失败，需要进行Full GC</p><ul><li><strong>动态年龄判定</strong><br>新生代对象的年龄可能没达到阈值(MaxTenuringThreshold参数指定)就晋升老年代，如果Young GC之后，新生代存活对象<strong>达到相同年龄所有对象大小</strong>的总和大于任一Survivor空间(S0 或 S1总空间)的一半，此时S0或者S1区即将容纳不了存活的新生代对象，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄</li></ul><p>另外，如果Young GC后S0或S1区不足以容纳：未达到晋升老年代条件的新生代存活对象，会导致这些存活对象直接进入老年代，需要尽量避免</p><h1 id="CMS原理及调优"><a href="#CMS原理及调优" class="headerlink" title="CMS原理及调优"></a>CMS原理及调优</h1><h2 id="1-名词解释"><a href="#1-名词解释" class="headerlink" title="1 名词解释"></a>1 名词解释</h2><p><strong>可达性分析算法</strong>：用于判断对象是否存活，基本思想是通过一系列称为“GC Root”的对象作为起点（常见的GC Root有系统类加载器、栈中的对象、处于激活状态的线程等），基于对象引用关系，从GC Roots开始向下搜索，所走过的路径称为引用链，当一个对象到GC Root没有任何引用链相连，证明对象不再存活</p><p><strong>Stop The World</strong>：GC过程中分析对象引用关系，为了保证分析结果的准确性，需要通过停顿所有Java执行线程，保证引用关系不再动态变化，该停顿事件称为Stop The World(STW)</p><p><strong>Safepoint</strong>：代码执行过程中的一些特殊位置，当线程执行到这些位置的时候，说明虚拟机当前的状态是安全的，如果有需要GC，线程可以在这个位置暂停。HotSpot采用主动中断的方式，让执行线程在运行期轮询是否需要暂停的标志，若需要则中断挂起</p><h2 id="2-CMS简介"><a href="#2-CMS简介" class="headerlink" title="2 CMS简介"></a>2 CMS简介</h2><p>CMS(Concurrent Mark and Swee 并发-标记-清除)，是一款基于并发、使用标记清除算法的垃圾回收算法，只针对老年代进行垃圾回收。CMS收集器工作时，尽可能让GC线程和用户线程并发执行，以达到降低STW时间的目的</p><p>通过以下命令行参数，启用CMS垃圾收集器:</p><pre><code>-XX:+UseConcMarkSweepGC</code></pre><p>值得补充的是，下面介绍到的CMS GC是指老年代的GC，而Full GC指的是整个堆的GC事件，包括新生代、老年代、元空间等，两者有所区分</p><h2 id="3-新生代垃圾回收"><a href="#3-新生代垃圾回收" class="headerlink" title="3 新生代垃圾回收"></a>3 新生代垃圾回收</h2><p>能与CMS搭配使用的新生代垃圾收集器有Serial收集器和ParNew收集器。这2个收集器都采用标记复制算法，都会触发STW事件，停止所有的应用线程。不同之处在于，Serial是单线程执行，ParNew是多线程执行</p><p><img src="/images/%E7%90%86%E8%A7%A3Java-GC%E5%8E%9F%E7%90%86%E5%92%8C%E8%B0%83%E4%BC%98/5.png" alt="新生代"> </p><h2 id="4-老年代垃圾回收"><a href="#4-老年代垃圾回收" class="headerlink" title="4 老年代垃圾回收"></a>4 老年代垃圾回收</h2><p>CMS GC以获取最小停顿时间为目的，尽可能减少STW时间，可以分为7个阶段</p><p><img src="/images/%E7%90%86%E8%A7%A3Java-GC%E5%8E%9F%E7%90%86%E5%92%8C%E8%B0%83%E4%BC%98/6.png" alt="CMS 7个阶段"></p><ul><li><strong>阶段 1: 初始标记(Initial Mark)</strong></li></ul><p>此阶段的目标是标记老年代中所有存活的对象, 包括 GC Root 的直接引用, 以及由新生代中存活对象所引用的对象，触发第一次STW事件</p><p>这个过程是支持多线程的（JDK7之前单线程，JDK8之后并行，可通过参数CMSParallelInitialMarkEnabled调整）</p><p><img src="/images/%E7%90%86%E8%A7%A3Java-GC%E5%8E%9F%E7%90%86%E5%92%8C%E8%B0%83%E4%BC%98/7.png" alt="初始标记"></p><ul><li><strong>阶段 2: 并发标记(Concurrent Mark)</strong></li></ul><p>此阶段GC线程和应用线程并发执行，遍历阶段1初始标记出来的存活对象，然后继续递归标记这些对象可达的对象</p><p><img src="/images/%E7%90%86%E8%A7%A3Java-GC%E5%8E%9F%E7%90%86%E5%92%8C%E8%B0%83%E4%BC%98/8.png" alt="并发标记"></p><ul><li><strong>阶段 3: 并发预清理(Concurrent Preclean)</strong></li></ul><p>此阶段GC线程和应用线程也是并发执行，因为阶段2是与应用线程并发执行，可能有些引用关系已经发生改变。<br>通过卡片标记(Card Marking)，提前把老年代空间逻辑划分为相等大小的区域(Card)，如果引用关系发生改变，JVM会将发生改变的区域标记位“脏区”(Dirty Card)，然后在本阶段，这些脏区会被找出来，刷新引用关系，清除“脏区”标记</p><p><img src="/images/%E7%90%86%E8%A7%A3Java-GC%E5%8E%9F%E7%90%86%E5%92%8C%E8%B0%83%E4%BC%98/9.png" alt="并发预清理"></p><ul><li><strong>阶段 4: 并发可取消的预清理(Concurrent Abortable Preclean)</strong></li></ul><p>此阶段也不停止应用线程. 本阶段尝试在 STW 的 最终标记阶段(Final Remark)之前尽可能地多做一些工作，以减少应用暂停时间<br>在该阶段不断循环处理：标记老年代的可达对象、扫描处理Dirty Card区域中的对象，循环的终止条件有：<br>1 达到循环次数<br>2 达到循环执行时间阈值<br>3 新生代内存使用率达到阈值</p><ul><li><strong>阶段 5: 最终标记(Final Remark)</strong></li></ul><p>这是GC事件中第二次(也是最后一次)STW阶段，目标是完成老年代中所有存活对象的标记。在此阶段执行：<br>1 遍历新生代对象，重新标记<br>2 根据GC Roots，重新标记<br>3 遍历老年代的Dirty Card，重新标记</p><ul><li><strong>阶段 6: 并发清除(Concurrent Sweep)</strong></li></ul><p>此阶段与应用程序并发执行，不需要STW停顿，根据标记结果清除垃圾对象</p><p><img src="/images/%E7%90%86%E8%A7%A3Java-GC%E5%8E%9F%E7%90%86%E5%92%8C%E8%B0%83%E4%BC%98/10.png" alt="并发清除"></p><ul><li><strong>阶段 7: 并发重置(Concurrent Reset)</strong></li></ul><p>此阶段与应用程序并发执行，重置CMS算法相关的内部数据, 为下一次GC循环做准备</p><h2 id="5-CMS常见问题"><a href="#5-CMS常见问题" class="headerlink" title="5 CMS常见问题"></a>5 CMS常见问题</h2><h4 id="最终标记阶段停顿时间过长问题"><a href="#最终标记阶段停顿时间过长问题" class="headerlink" title="最终标记阶段停顿时间过长问题"></a>最终标记阶段停顿时间过长问题</h4><p>CMS的GC停顿时间约80%都在最终标记阶段(Final Remark)，若该阶段停顿时间过长，常见原因是新生代对老年代的无效引用，在上一阶段的并发可取消预清理阶段中，执行阈值时间内未完成循环，来不及触发Young GC，清理这些无效引用</p><p>通过添加参数：-XX:+CMSScavengeBeforeRemark。在执行最终操作之前先触发Young GC，从而减少新生代对老年代的无效引用，降低最终标记阶段的停顿，但如果在上个阶段(并发可取消的预清理)已触发Young GC，也会重复触发Young GC</p><h4 id="并发模式失败-concurrent-mode-failure-amp-晋升失败-promotion-failed-问题"><a href="#并发模式失败-concurrent-mode-failure-amp-晋升失败-promotion-failed-问题" class="headerlink" title="并发模式失败(concurrent mode failure) &amp; 晋升失败(promotion failed)问题"></a>并发模式失败(concurrent mode failure) &amp; 晋升失败(promotion failed)问题</h4><p><img src="/images/%E7%90%86%E8%A7%A3Java-GC%E5%8E%9F%E7%90%86%E5%92%8C%E8%B0%83%E4%BC%98/11.png" alt="并发模式失败"><br><strong>并发模式失败</strong>：当CMS在执行回收时，新生代发生垃圾回收，同时老年代又没有足够的空间容纳晋升的对象时，CMS 垃圾回收就会退化成单线程的Full GC。所有的应用线程都会被暂停，老年代中所有的无效对象都被回收</p><p><img src="/images/%E7%90%86%E8%A7%A3Java-GC%E5%8E%9F%E7%90%86%E5%92%8C%E8%B0%83%E4%BC%98/12.png" alt="晋升失败"><br><strong>晋升失败</strong>：当新生代发生垃圾回收，老年代有足够的空间可以容纳晋升的对象，但是由于空闲空间的碎片化，导致晋升失败，此时会触发单线程且带压缩动作的Full GC</p><p>并发模式失败和晋升失败都会导致长时间的停顿，常见解决思路如下：</p><ul><li>降低触发CMS GC的阈值，即参数-XX:CMSInitiatingOccupancyFraction的值，让CMS GC尽早执行，以保证有足够的空间</li><li>增加CMS线程数，即参数-XX:ConcGCThreads，</li><li>增大老年代空间</li><li>让对象尽量在新生代回收，避免进入老年代</li></ul><h4 id="内存碎片问题"><a href="#内存碎片问题" class="headerlink" title="内存碎片问题"></a>内存碎片问题</h4><p>通常CMS的GC过程基于标记清除算法，不带压缩动作，导致越来越多的内存碎片需要压缩，常见以下场景会触发内存碎片压缩：</p><ul><li>新生代Young GC出现新生代晋升担保失败(promotion failed)</li><li>程序主动执行System.gc()</li></ul><p>可通过参数CMSFullGCsBeforeCompaction的值，设置多少次Full GC触发一次压缩，默认值为0，代表每次进入Full GC都会触发压缩，带压缩动作的算法为上面提到的单线程Serial Old算法，暂停时间(STW)时间非常长，需要尽可能减少压缩时间</p><h1 id="G1原理及调优"><a href="#G1原理及调优" class="headerlink" title="G1原理及调优"></a>G1原理及调优</h1><h2 id="1-G1简介"><a href="#1-G1简介" class="headerlink" title="1 G1简介"></a>1 G1简介</h2><p>G1(Garbage-First）是一款面向服务器的垃圾收集器，支持新生代和老年代空间的垃圾收集，主要针对配备多核处理器及大容量内存的机器，G1最主要的设计目标是: <strong>实现可预期及可配置的STW停顿时间</strong></p><h2 id="2-G1堆空间划分"><a href="#2-G1堆空间划分" class="headerlink" title="2 G1堆空间划分"></a>2 G1堆空间划分</h2><p><img src="/images/%E7%90%86%E8%A7%A3Java-GC%E5%8E%9F%E7%90%86%E5%92%8C%E8%B0%83%E4%BC%98/13.png" alt="G1收集器堆空间"></p><ul><li><strong>Region</strong></li></ul><p>为实现大内存空间的低停顿时间的回收，将划分为多个大小相等的Region。每个小堆区都可能是 Eden区，Survivor区或者Old区，但是在同一时刻只能属于某个代</p><p>在逻辑上, 所有的Eden区和Survivor区合起来就是新生代，所有的Old区合起来就是老年代，且新生代和老年代各自的内存Region区域由G1自动控制，不断变动</p><ul><li><strong>巨型对象</strong></li></ul><p>当对象大小超过Region的一半，则认为是巨型对象(Humongous Object)，直接被分配到老年代的巨型对象区(Humongous regions)，这些巨型区域是一个连续的区域集，每一个Region中最多有一个巨型对象，巨型对象可以占多个Region</p><p>G1把堆内存划分成一个个Region的意义在于：</p><ul><li>每次GC不必都去处理整个堆空间，而是每次只处理一部分Region，实现大容量内存的GC</li><li>通过计算每个Region的回收价值，包括回收所需时间、可回收空间，<strong>在有限时间内尽可能回收更多的垃圾对象</strong>，把垃圾回收造成的停顿时间控制在预期配置的时间范围内，这也是G1名称的由来: <strong>garbage-first</strong></li></ul><h2 id="3-G1工作模式"><a href="#3-G1工作模式" class="headerlink" title="3 G1工作模式"></a>3 G1工作模式</h2><p>针对新生代和老年代，G1提供2种GC模式，Young GC和Mixed GC，两种会导致Stop The World</p><ul><li><p>Young GC<br>当新生代的空间不足时，G1触发Young GC回收新生代空间<br>Young GC主要是对Eden区进行GC，它在Eden空间耗尽时触发，基于分代回收思想和复制算法，每次Young GC都会选定所有新生代的Region，同时计算下次Young GC所需的Eden区和Survivor区的空间，动态调整新生代所占Region个数来控制Young GC开销</p></li><li><p>Mixed GC<br>当老年代空间达到阈值会触发Mixed GC，选定所有新生代里的Region，根据全局并发标记阶段(下面介绍到)统计得出收集收益高的若干老年代 Region。在用户指定的开销目标范围内，尽可能选择收益高的老年代Region进行GC，通过选择哪些老年代Region和选择多少Region来控制Mixed GC开销</p></li></ul><h2 id="4-全局并发标记"><a href="#4-全局并发标记" class="headerlink" title="4 全局并发标记"></a>4 全局并发标记</h2><p><strong>全局并发标记</strong>主要是为Mixed GC计算找出回收收益较高的Region区域，具体分为5个阶段</p><p><img src="/images/%E7%90%86%E8%A7%A3Java-GC%E5%8E%9F%E7%90%86%E5%92%8C%E8%B0%83%E4%BC%98/14.png" alt="全局并发标记"></p><ul><li><p><strong>阶段 1: 初始标记(Initial Mark)</strong><br>暂停所有应用线程（STW），并发地进行标记从 GC Root 开始直接可达的对象（原生栈对象、全局对象、JNI 对象），当达到触发条件时，G1 并不会立即发起并发标记周期，而是等待下一次新生代收集，利用新生代收集的 STW 时间段，完成初始标记，这种方式称为借道（Piggybacking）</p></li><li><p><strong>阶段 2: 根区域扫描（Root Region Scan）</strong><br>在初始标记暂停结束后，新生代收集也完成的对象复制到 Survivor 的工作，应用线程开始活跃起来；<br>此时为了保证标记算法的正确性，所有新复制到 Survivor 分区的对象，需要找出哪些对象存在对老年代对象的引用，把这些对象标记成根(Root)；<br>这个过程称为根分区扫描（Root Region Scanning），同时扫描的 Suvivor 分区也被称为根分区（Root Region）；<br>根分区扫描必须在下一次新生代垃圾收集启动前完成（接下来并发标记的过程中，可能会被若干次新生代垃圾收集打断），因为每次 GC 会产生新的存活对象集合</p></li><li><p><strong>阶段 3: 并发标记（Concurrent Marking）</strong><br>标记线程与应用程序线程并行执行，标记各个堆中Region的存活对象信息，这个步骤可能被新的 Young GC 打断<br>所有的标记任务必须在堆满前就完成扫描，如果并发标记耗时很长，那么有可能在并发标记过程中，又经历了几次新生代收集</p></li><li><p><strong>阶段 4: 再次标记(Remark)</strong><br>和CMS类似暂停所有应用线程（STW），以完成标记过程短暂地停止应用线程, 标记在并发标记阶段发生变化的对象，和所有未被标记的存活对象，同时完成存活数据计算</p></li><li><p><strong>阶段 5: 清理(Cleanup)</strong><br>为即将到来的转移阶段做准备, 此阶段也为下一次标记执行所有必需的整理计算工作：</p><ul><li>整理更新每个Region各自的RSet(remember set，HashMap结构，记录有哪些老年代对象指向本Region，key为指向本Region的对象的引用，value为指向本Region的具体Card区域，通过RSet可以确定Region中对象存活信息，避免全堆扫描)</li><li>回收不包含存活对象的Region</li><li>统计计算回收收益高（基于释放空间和暂停目标）的老年代分区集合</li></ul></li></ul><h2 id="5-G1调优注意点"><a href="#5-G1调优注意点" class="headerlink" title="5 G1调优注意点"></a>5 G1调优注意点</h2><h3 id="Full-GC问题"><a href="#Full-GC问题" class="headerlink" title="Full GC问题"></a>Full GC问题</h3><p>G1的正常处理流程中没有Full GC，只有在垃圾回收处理不过来(或者主动触发)时才会出现， G1的Full GC就是单线程执行的Serial old gc，会导致非常长的STW，是调优的重点，需要尽量避免Full GC，常见原因如下：</p><ul><li>程序主动执行System.gc()</li><li>全局并发标记期间老年代空间被填满（并发模式失败）</li><li>Mixed GC期间老年代空间被填满（晋升失败）</li><li>Young GC时Survivor空间和老年代没有足够空间容纳存活对象</li></ul><p>类似CMS，常见的解决是：</p><ul><li>增大-XX:ConcGCThreads=n 选项增加并发标记线程的数量，或者STW期间并行线程的数量：-XX:ParallelGCThreads=n</li><li>减小-XX:InitiatingHeapOccupancyPercent 提前启动标记周期</li><li>增大预留内存 -XX:G1ReservePercent=n ，默认值是10，代表使用10%的堆内存为预留内存，当Survivor区域没有足够空间容纳新晋升对象时会尝试使用预留内存</li></ul><h3 id="巨型对象分配"><a href="#巨型对象分配" class="headerlink" title="巨型对象分配"></a>巨型对象分配</h3><p>巨型对象区中的每个Region中包含一个巨型对象，剩余空间不再利用，导致空间碎片化，当G1没有合适空间分配巨型对象时，G1会启动串行Full GC来释放空间。可以通过增加 -XX:G1HeapRegionSize来增大Region大小，这样一来，相当一部分的巨型对象就不再是巨型对象了，而是采用普通的分配方式</p><h3 id="不要设置Young区的大小"><a href="#不要设置Young区的大小" class="headerlink" title="不要设置Young区的大小"></a>不要设置Young区的大小</h3><p>原因是为了尽量满足目标停顿时间，逻辑上的Young区会进行动态调整。如果设置了大小，则会覆盖掉并且会禁用掉对停顿时间的控制</p><h3 id="平均响应时间设置"><a href="#平均响应时间设置" class="headerlink" title="平均响应时间设置"></a>平均响应时间设置</h3><p>使用应用的平均响应时间作为参考来设置MaxGCPauseMillis，JVM会尽量去满足该条件，可能是90%的请求或者更多的响应时间在这之内， 但是并不代表是所有的请求都能满足，平均响应时间设置过小会导致频繁GC</p><h1 id="调优方法与思路"><a href="#调优方法与思路" class="headerlink" title="调优方法与思路"></a>调优方法与思路</h1><p>如何分析系统JVM GC运行状况及合理优化？</p><p>GC优化的核心思路在于：<strong>尽可能让对象在新生代中分配和回收，尽量避免过多对象进入老年代，导致对老年代频繁进行垃圾回收，同时给系统足够的内存减少新生代垃圾回收次数</strong>，进行系统分析和优化也是围绕着这个思路展开</p><h2 id="1-分析系统的运行状况"><a href="#1-分析系统的运行状况" class="headerlink" title="1 分析系统的运行状况"></a>1 分析系统的运行状况</h2><ul><li>系统每秒请求数、每个请求创建多少对象，占用多少内存</li><li>Young GC触发频率、对象进入老年代的速率</li><li>老年代占用内存、Full GC触发频率、Full GC触发的原因、长时间Full GC的原因</li></ul><p>常用工具如下：</p><ul><li><strong>jstat</strong><br>jvm自带命令行工具，可用于统计内存分配速率、GC次数，GC耗时，常用命令格式<pre><code>jstat -gc &lt;pid&gt; &lt;统计间隔时间&gt;  &lt;统计次数&gt;</code></pre></li></ul><p>输出返回值代表含义如下：</p><p><img src="/images/%E7%90%86%E8%A7%A3Java-GC%E5%8E%9F%E7%90%86%E5%92%8C%E8%B0%83%E4%BC%98/15.png" alt="jstat"></p><p>例如： jstat -gc 32683 1000 10 ，统计pid=32683的进程，每秒统计1次，统计10次</p><ul><li><strong>jmap</strong><br>jvm自带命令行工具，可用于了解系统运行时的对象分布，常用命令格式如下<pre><code>// 命令行输出类名、类数量数量，类占用内存大小，// 按照类占用内存大小降序排列jmap -histo &lt;pid&gt;</code></pre></li></ul><p>// 生成堆内存转储快照，在当前目录下导出dump.hrpof的二进制文件，<br>// 可以用eclipse的MAT图形化工具分析<br>jmap -dump:live,format=b,file=dump.hprof <pid></pid></p><pre><code>* **jinfo**命令格式</code></pre><p>jinfo <pid> </pid></p><pre><code>用来查看正在运行的 Java 应用程序的扩展参数，包括Java System属性和JVM命令行参数其他GC工具* 监控告警系统：Zabbix、Prometheus、Open-Falcon* jdk自动实时内存监控工具：VisualVM* 堆外内存监控： Java VisualVM安装Buffer Pools 插件、google perf工具、Java NMT(Native Memory Tracking)工具* GC日志分析：GCViewer、gceasy* GC参数检查和优化：http://xxfox.perfma.com/## 2 GC优化案例* **数据分析平台系统频繁Full GC**平台主要对用户在APP中行为进行定时分析统计，并支持报表导出，使用CMS GC算法。数据分析师在使用中发现系统页面打开经常卡顿，通过jstat命令发现系统每次Young GC后大约有10%的存活对象进入老年代。原来是因为Survivor区空间设置过小，每次Young GC后存活对象在Survivor区域放不下，提前进入老年代，通过调大Survivor区，使得Survivor区可以容纳Young GC后存活对象，对象在Survivor区经历多次Young GC达到年龄阈值才进入老年代，调整之后每次Young GC后进入老年代的存活对象稳定运行时仅几百Kb，Full GC频率大大降低* **业务对接网关OOM**网关主要消费Kafka数据，进行数据处理计算然后转发到另外的Kafka队列，系统运行几个小时候出现OOM，重启系统几个小时之后又OOM，通过jmap导出堆内存，在eclipse MAT工具分析才找出原因：代码中将某个业务Kafka的topic数据进行日志异步打印，该业务数据量较大，大量对象堆积在内存中等待被打印，导致OOM* **账号权限管理系统频繁长时间Full GC**系统对外提供各种账号鉴权服务，使用时发现系统经常服务不可用，通过Zabbix的监控平台监控发现系统频繁发生长时间Full GC，且触发时老年代的堆内存通常并没有占满，发现原来是业务代码中调用了System.gc()# 总结GC问题可以说没有捷径，排查线上的性能问题本身就并不简单，除了将本文介绍到的原理和工具融会贯通，还需要我们不断去积累经验，真正做到性能最优篇幅所限，不再展开介绍常见GC参数的使用，我发布在github：https://github.com/caison/caison-blog-demo# 参考《Java Performance: The Definitive Guide》 Scott Oaks《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》 周志华[Java性能调优实战](http://gk.link/a/108k3)[Getting Started with the G1 Garbage Collector](https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html)[GC参考手册-Java版](https://github.com/cncounter/gc-handbook)[请教G1算法的原理——RednaxelaFX的回答](https://link.jianshu.com/?t=http://hllvm.group.iteye.com/group/topic/44381#post-272188)[Java Hotspot G1 GC的一些关键技术——美团技术团队](https://zhuanlan.zhihu.com/p/22591838)![](/images/理解Java-GC原理和调优/16.png)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>理解Java内存模型</title>
      <link href="/2019/10/13/li-jie-java-nei-cun-mo-xing/"/>
      <url>/2019/10/13/li-jie-java-nei-cun-mo-xing/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E7%90%86%E8%A7%A3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/0.jpg" alt></p><pre><code>文章首发于51CTO技术栈公众号作者 陈彩华文章转载交流请联系 caison@aliyun.com</code></pre><p>最近重新学习一遍《深入学习Java虚拟机》，把之前Java内存模型中模糊的知识重新梳理一遍，这篇文章主要介绍模型产生的问题背景，解决的问题，处理思路，相关实现规则，环环相扣，希望读者看完这篇文章后能对Java内存模型体系产生一个相对清晰的理解，知其然而知其所以然。</p><h1 id="1-内存模型产生背景"><a href="#1-内存模型产生背景" class="headerlink" title="1 内存模型产生背景"></a>1 内存模型产生背景</h1><p>在介绍Java内存模型之前，我们先了解一下物理计算机中的并发问题，理解这些问题可以搞清楚内存模型产生的背景。物理机遇到的并发问题与虚拟机中的情况有不少相似之处，物理机的解决方案对虚拟机的实现有相当的参考意义。</p><h2 id="物理机的并发问题"><a href="#物理机的并发问题" class="headerlink" title="物理机的并发问题"></a>物理机的并发问题</h2><ul><li><strong>硬件的效率问题</strong></li></ul><p>计算机处理器处理绝大多数运行任务都不可能只靠处理器“计算”就能完成，处理器至少需要与<strong>内存交互</strong>，如读取运算数据、存储运算结果，这个I/O操作很难消除(无法仅靠寄存器完成所有运算任务)。</p><p>由于计算机的存储设备与处理器的运算速度有几个数量级的差距，为了避免处理器等待缓慢的内存读写操作完成，现代计算机系统通过加入一层读写速度尽可能接近处理器运算速度的高速缓存。缓存作为内存和处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速运行，当运算结束后再从缓存同步回内存之中。<br><img src="/images/%E7%90%86%E8%A7%A3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1.png" alt="CPU高速缓存"></p><ul><li><strong>缓存一致性问题</strong></li></ul><p>基于高速缓存的存储系统交互很好地解决了处理器与内存速度的矛盾，但是也为计算机系统带来更高的复杂度，因为引入了一个新问题：<strong>缓存一致性。</strong></p><p>在多处理器的系统中(或者单处理器多核的系统)，每个处理器(每个核)都有自己的高速缓存，而它们有共享同一主内存(Main Memory)。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。<br>为此，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议进行操作，来维护缓存的一致性。</p><p><img src="/images/%E7%90%86%E8%A7%A3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/2.png" alt="缓存一致性"></p><ul><li><strong>代码乱序执行优化问题</strong></li></ul><p>为了使得处理器内部的运算单元尽量被充分利用，提高运算效率，处理器可能会对输入的代码进行乱序执行，处理器会在计算之后将乱序执行的结果重组，<strong>乱序优化可以保证在单线程下该执行结果与顺序执行的结果是一致的</strong>，但不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。</p><p><img src="/images/%E7%90%86%E8%A7%A3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/3.png" alt="代码执行乱序优化"><br>乱序执行技术是处理器为提高运算速度而做出违背代码原有顺序的优化。在单核时代，处理器保证做出的优化不会导致执行结果远离预期目标，但在多核环境下却并非如此。</p><p>多核环境下， 如果存在一个核的计算任务依赖另一个核 计的算任务的中间结果，而且对相关数据读写没做任何防护措施，那么其顺序性并不能靠代码的先后顺序来保证，处理器最终得出的结果和我们逻辑得到的结果可能会大不相同。</p><p><img src="/images/%E7%90%86%E8%A7%A3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/4.png" alt="代码乱序执行优化的问题"><br>以上图为例进行说明：CPU的core2中的逻辑B依赖core1中的逻辑A先执行</p><ul><li>正常情况下，逻辑A执行完之后再执行逻辑B。</li><li>在处理器乱序执行优化情况下，有可能导致flag提前被设置为true，导致逻辑B先于逻辑A执行。</li></ul><h1 id="2-Java内存模型的组成分析"><a href="#2-Java内存模型的组成分析" class="headerlink" title="2 Java内存模型的组成分析"></a>2 Java内存模型的组成分析</h1><h2 id="内存模型概念"><a href="#内存模型概念" class="headerlink" title="内存模型概念"></a>内存模型概念</h2><p>为了更好解决上面提到系列问题，内存模型被总结提出，我们可以把内存模型理解为<strong>在特定操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象</strong>。</p><p>不同架构的物理计算机可以有不一样的内存模型，Java虚拟机也有自己的内存模型。Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，简称JMM）来<strong>屏蔽掉各种硬件和操作系统的内存访问差异</strong>，以实现<strong>让Java程序在各种平台下都能达到一致的内存访问效果</strong>，不必因为不同平台上的物理机的内存模型的差异，对各平台定制化开发程序。</p><p>更具体一点说，Java内存模型提出目标在于，<strong>定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节</strong>。此处的变量(Variables)与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数值对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的。(如果局部变量是一个reference类型，它引用的对象在Java堆中可被各个线程共享，但是reference本身在Java栈的局部变量表中，它是线程私有的)。</p><h2 id="Java内存模型的组成"><a href="#Java内存模型的组成" class="headerlink" title="Java内存模型的组成"></a>Java内存模型的组成</h2><ul><li><p>主内存<br>Java内存模型规定了所有变量都存储在主内存(Main Memory)中（此处的主内存与介绍物理硬件的主内存名字一样，两者可以互相类比，但此处仅是虚拟机内存的一部分）。</p></li><li><p>工作内存<br>每条线程都有自己的工作内存(Working Memory，又称本地内存，可与前面介绍的处理器高速缓存类比)，线程的工作内存中保存了该线程使用到的变量的主内存中的共享变量的副本拷贝。<strong>工作内存是 JMM 的一个抽象概念，并不真实存在</strong>。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。</p></li></ul><p>Java内存模型抽象示意图如下：</p><p><img src="/images/%E7%90%86%E8%A7%A3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/5.png" alt="Java内存模型抽象示意图"></p><h2 id="JVM内存操作的并发问题"><a href="#JVM内存操作的并发问题" class="headerlink" title="JVM内存操作的并发问题"></a>JVM内存操作的并发问题</h2><p>结合前面介绍的物理机的处理器处理内存的问题，可以类比总结出JVM内存操作的问题，下面介绍的Java内存模型的执行处理将围绕解决这2个问题展开：</p><ul><li><p><strong>1 工作内存数据一致性</strong><br>各个线程操作数据时会保存使用到的主内存中的共享变量副本，当多个线程的运算任务都涉及同一个共享变量时，将导致各自的的共享变量副本不一致，如果真的发生这种情况，数据同步回主内存以谁的副本数据为准？<br>Java内存模型主要通过一系列的数据同步协议、规则来保证数据的一致性，后面再详细介绍。</p></li><li><p><strong>2 指令重排序优化</strong><br>Java中重排序通常是编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段。重排序分为两类：<strong>编译期重排序和运行期重排序</strong>，分别对应编译时和运行时环境。<br>同样的，指令重排序不是随意重排序，它需要满足以下两个条件： </p><ul><li>1 在单线程环境下不能改变程序运行的结果<br>即时编译器（和处理器）需要保证程序能够遵守 as-if-serial 属性。通俗地说，就是在单线程情况下，要给程序一个顺序执行的假象。即经过重排序的执行结果要与顺序执行的结果保持一致。</li><li>2 存在数据依赖关系的不允许重排序</li></ul></li></ul><p>多线程环境下，如果线程处理逻辑之间存在依赖关系，有可能因为指令重排序导致运行结果与预期不同，后面再展开Java内存模型如何解决这种情况。</p><h1 id="3-Java内存间的交互操作"><a href="#3-Java内存间的交互操作" class="headerlink" title="3 Java内存间的交互操作"></a>3 Java内存间的交互操作</h1><p>在理解Java内存模型的系列协议、特殊规则之前，我们先理解Java中内存间的交互操作。</p><h2 id="交互操作流程"><a href="#交互操作流程" class="headerlink" title="交互操作流程"></a>交互操作流程</h2><p>为了更好理解内存的交互操作，以线程通信为例，我们看看具体如何进行线程间值的同步：</p><p><img src="/images/%E7%90%86%E8%A7%A3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/6.png" alt="线程间交互操作"><br>线程1和线程2都有主内存中共享变量x的副本，初始时，这3个内存中x的值都为0。线程1中更新x的值为1之后同步到线程2主要涉及2个步骤：</p><ul><li>1 线程1把线程工作内存中更新过的x的值刷新到主内存中</li><li>2 线程2到主内存中读取线程1之前已更新过的x变量</li></ul><p>从整体上看，这2个步骤是线程1在向线程2发消息，这个通信过程必须经过主内存。线程对变量的所有操作（读取，赋值）都必须在<strong>工作内存中</strong>进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，实现各个线程共享变量的可见性。</p><h2 id="内存交互的基本操作"><a href="#内存交互的基本操作" class="headerlink" title="内存交互的基本操作"></a>内存交互的基本操作</h2><p>关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了下面介绍8种操作来完成。</p><p>虚拟机实现时必须保证下面介绍的每种操作都是原子的，不可再分的(对于double和long型的变量来说，load、store、read、和write操作在某些平台上允许有例外，后面会介绍）。</p><h3 id="8种基本操作"><a href="#8种基本操作" class="headerlink" title="8种基本操作"></a>8种基本操作</h3><p><img src="/images/%E7%90%86%E8%A7%A3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/7.png" alt="8种基本操作"></p><ul><li>lock (锁定)<br>作用于<strong>主内存</strong>的变量，它把一个变量标识为一条线程独占的状态。</li><li>unlock (解锁)<br>作用于<strong>主内存</strong>的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li>read (读取)<br>作用于<strong>主内存</strong>的变量，它把一个变量的值从主内存<strong>传输</strong>到线程的工作内存中，以便随后的load动作使用。</li><li>load (载入)<br>作用于<strong>工作内存</strong>的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li>use (使用)<br>作用于<strong>工作内存</strong>的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时就会执行这个操作。</li><li>assign (赋值)<br>作用于<strong>工作内存</strong>的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li>store (存储)<br>作用于<strong>工作内存</strong>的变量，它把工作内存中一个变量的值传送到主内存中，以便随后write操作使用。</li><li>write (写入)<br>作用于<strong>主内存</strong>的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li></ul><h1 id="4-Java内存模型运行规则"><a href="#4-Java内存模型运行规则" class="headerlink" title="4 Java内存模型运行规则"></a>4 Java内存模型运行规则</h1><h2 id="4-1-内存交互基本操作的3个特性"><a href="#4-1-内存交互基本操作的3个特性" class="headerlink" title="4.1 内存交互基本操作的3个特性"></a>4.1 内存交互基本操作的3个特性</h2><p>在介绍内存的交互的具体的8种基本操作之前，有必要先介绍一下操作的3个特性，Java内存模型是围绕着在并发过程中如何处理这3个特性来建立的，这里先给出定义和基本实现的简单介绍，后面会逐步展开分析。</p><ul><li><p><strong>原子性(Atomicity)</strong></p></li><li><p><em>即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行*</em>。即使在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。</p></li><li><p><strong>可见性(Visibility)</strong></p></li><li><p><em>是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值*</em>。<br>正如上面“交互操作流程”中所说明的一样，JMM是通过在线程1变量工作内存修改后将新值同步回主内存，线程2在变量读取前从主内存刷新变量值，这种<strong>依赖主内存作为传递媒介</strong>的方式来实现可见性。</p></li><li><p><strong>有序性(Ordering)</strong><br>有序性规则表现在以下两种场景: 线程内和线程间</p><ul><li>线程内<br>从某个线程的角度看方法的执行，指令会按照一种叫“串行”（as-if-serial）的方式执行，此种方式已经应用于顺序编程语言。</li><li>线程间<br>这个线程“观察”到其他线程并发地执行非同步的代码时，由于指令重排序优化，任何代码都有可能交叉执行。唯一起作用的约束是：对于同步方法，同步块(synchronized关键字修饰)以及volatile字段的操作仍维持相对有序。</li></ul></li></ul><p>Java内存模型的一系列运行规则看起来有点繁琐，但总结起来，是<strong>围绕原子性、可见性、有序性特征建立</strong>。归根究底，是为实现共享变量的在多个线程的工作内存的<strong>数据一致性</strong>，多线程并发，指令重排序优化的环境中程序能如预期运行。</p><h2 id="4-2-happens-before关系"><a href="#4-2-happens-before关系" class="headerlink" title="4.2 happens-before关系"></a>4.2 happens-before关系</h2><p>介绍系列规则之前，首先了解一下happens-before关系：用于描述下2个操作的内存可见性：<strong>如果操作A happens-before 操作B，那么A的结果对B可见</strong>。happens-before关系的分析需要分为<strong>单线程和多线程</strong>的情况：</p><ul><li><p><strong>单线程下的 happens-before</strong><br>字节码的先后顺序天然包含happens-before关系：因为单线程内共享一份工作内存，不存在数据一致性的问题。<br>在程序控制流路径中靠前的字节码 happens-before 靠后的字节码，即靠前的字节码执行完之后操作结果对靠后的字节码可见。然而，这并不意味着前者一定在后者之前执行。实际上，如果后者不依赖前者的运行结果，那么它们可能会被重排序。</p></li><li><p><strong>多线程下的 happens-before</strong><br>多线程由于每个线程有共享变量的副本，如果没有对共享变量做同步处理，线程1更新执行操作A共享变量的值之后，线程2开始执行操作B，此时操作A产生的结果对操作B不一定可见。</p></li></ul><p>为了方便程序开发，Java内存模型实现了下述支持happens-before关系的操作：</p><ul><li>程序次序规则<br>一个线程内，按照代码顺序，书写在前面的操作 happens-before 书写在后面的操作。</li><li>锁定规则<br>一个unLock操作 happens-before 后面对同一个锁的lock操作。</li><li>volatile变量规则<br>对一个变量的写操作 happens-before 后面对这个变量的读操作。</li><li>传递规则<br>如果操作A happens-before  操作B，而操作B又 happens-before 操作C，则可以得出操作A happens-before 操作C。</li><li>线程启动规则<br>Thread对象的start()方法 happens-before 此线程的每个一个动作。</li><li>线程中断规则<br>对线程interrupt()方法的调用 happens-before 被中断线程的代码检测到中断事件的发生。</li><li>线程终结规则<br>线程中所有的操作都 happens-before 线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行。</li><li>对象终结规则<br>一个对象的初始化完成 happens-before 他的finalize()方法的开始</li></ul><h2 id="4-3-内存屏障"><a href="#4-3-内存屏障" class="headerlink" title="4.3 内存屏障"></a>4.3 内存屏障</h2><p>Java中如何保证底层操作的有序性和可见性？可以通过内存屏障。</p><p>内存屏障是被插入两个CPU指令之间的一种指令，用来禁止处理器指令发生重排序（像屏障一样），从而保障<strong>有序性</strong>的。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列，从而保障<strong>可见性</strong>。</p><p>举个例子：</p><pre><code>Store1; Store2;   Load1;   StoreLoad;  //内存屏障Store3;   Load2;   Load3;</code></pre><p>对于上面的一组CPU指令（Store表示写入指令，Load表示读取指令），StoreLoad屏障之前的Store指令无法与StoreLoad屏障之后的Load指令进行交换位置，即<strong>重排序</strong>。但是StoreLoad屏障之前和之后的指令是可以互换位置的，即Store1可以和Store2互换，Load2可以和Load3互换。</p><p>常见有4种屏障</p><ul><li>LoadLoad屏障：<br>对于这样的语句 Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li><li>StoreStore屏障：<br>对于这样的语句 Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li><li>LoadStore屏障：<br>对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被执行前，保证Load1要读取的数据被读取完毕。</li><li>StoreLoad屏障：<br>对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的（冲刷写缓冲器，清空无效化队列）。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</li></ul><p>Java中对内存屏障的使用在一般的代码中不太容易见到，常见的有volatile和synchronized关键字修饰的代码块(后面再展开介绍)，还可以通过Unsafe这个类来使用内存屏障。</p><h2 id="4-4-8种操作同步的规则"><a href="#4-4-8种操作同步的规则" class="headerlink" title="4.4 8种操作同步的规则"></a>4.4 8种操作同步的规则</h2><p>JMM在执行前面介绍8种基本操作时，为了保证内存间数据一致性，JMM中规定需要满足以下规则：</p><ul><li>规则1：如果要把一个变量从主内存中复制到工作内存，就需要按顺序的执行 read 和 load 操作，如果把变量从工作内存中同步回主内存中，就要按顺序的执行 store 和 write 操作。但 Java 内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。</li><li>规则2：不允许 read 和 load、store 和 write 操作之一单独出现。</li><li>规则3：不允许一个线程丢弃它的最近 assign 的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li><li>规则4：不允许一个线程无原因的（没有发生过任何 assign 操作）把数据从工作内存同步回主内存中。</li><li>规则5：一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load 或 assign ）的变量。即就是对一个变量实施 use 和 store 操作之前，必须先执行过了 load 或 assign  操作。</li><li>规则6：一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。所以 lock 和 unlock 必须成对出现。</li><li>规则7：如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行 load 或 assign 操作初始化变量的值。</li><li>规则8：如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作；也不允许去 unlock 一个被其他线程锁定的变量。</li><li>规则9：对一个变量执行 unlock 操作之前，必须先把此变量同步到主内存中（执行 store 和 write 操作）</li></ul><p>看起来这些规则有些繁琐，其实也不难理解：</p><ul><li>规则1、规则2<br>工作内存中的共享变量作为主内存的副本，主内存变量的值同步到工作内存需要read和load一起使用，工作内存中的变量的值同步回主内存需要store和write一起使用，这2组操作各自都是是一个固定的有序搭配，不允许单独出现。</li><li>规则3、规则4<br>由于工作内存中的共享变量是主内存的副本，为保证数据一致性，当工作内存中的变量被字节码引擎重新赋值，必须同步回主内存。如果工作内存的变量没有被更新，不允许无原因同步回主内存。</li><li>规则5<br>由于工作内存中的共享变量是主内存的副本，必须从主内存诞生。</li><li>规则6、7、8、9<br>为了并发情况下安全使用变量，线程可以基于lock操作独占主内存中的变量，其他线程不允许使用或unlock该变量，直到变量被线程unlock。</li></ul><h2 id="4-5-volatile型变量的特殊规则"><a href="#4-5-volatile型变量的特殊规则" class="headerlink" title="4.5 volatile型变量的特殊规则"></a>4.5 volatile型变量的特殊规则</h2><p>volatile的中文意思是不稳定的，易变的，用volatile修饰变量是为了保证变量的可见性。</p><h3 id="volatile的语义"><a href="#volatile的语义" class="headerlink" title="volatile的语义"></a>volatile的语义</h3><p>volatile主要有下面2种语义</p><h3 id="语义1-保证可见性"><a href="#语义1-保证可见性" class="headerlink" title="语义1 保证可见性"></a>语义1 保证可见性</h3><p>保证了不同线程对该变量操作的内存可见性。</p><p>这里保证可见性是不等同于volatile变量并发操作的安全性，保证可见性具体一点解释：</p><p><strong>线程写volatile变量的过程：</strong></p><ul><li>1 改变线程工作内存中volatile变量副本的值</li><li>2 将改变后的副本的值从工作内存刷新到主内存</li></ul><p><strong>线程读volatile变量的过程：</strong></p><ul><li>1 从主内存中读取volatile变量的最新值到线程的工作内存中</li><li>2 从工作内存中读取volatile变量的副本</li></ul><p>但是如果多个线程同时把更新后的变量值同时刷新回主内存，可能导致得到的值不是预期结果：</p><p>举个例子：<br>定义volatile int count = 0，2个线程同时执行count++操作，每个线程都执行500次，最终结果小于1000，原因是每个线程执行count++需要以下3个步骤：</p><ul><li>步骤1 线程从主内存读取最新的count的值</li><li>步骤2 执行引擎把count值加1，并赋值给线程工作内存</li><li>步骤3 线程工作内存把count值保存到主内存<br>有可能某一时刻2个线程在步骤1读取到的值都是100，执行完步骤2得到的值都是101，最后刷新了2次101保存到主内存。</li></ul><h3 id="语义2-禁止进行指令重排序"><a href="#语义2-禁止进行指令重排序" class="headerlink" title="语义2 禁止进行指令重排序"></a>语义2 禁止进行指令重排序</h3><p>具体一点解释，禁止重排序的规则如下：</p><ul><li>当程序执行到 volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</li><li>在进行指令优化时，不能将在对 volatile 变量访问的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行。</li></ul><p>普通的变量仅仅会保证该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证赋值操作的顺序与程序代码中的执行顺序一致。</p><p>举个例子：</p><pre><code>volatile boolean initialized = false;// 下面代码线程A中执行// 读取配置信息，当读取完成后将initialized设置为true以通知其他线程配置可用doSomethingReadConfg();initialized = true;// 下面代码线程B中执行// 等待initialized 为true，代表线程A已经把配置信息初始化完成while (!initialized) {     sleep();}// 使用线程A初始化好的配置信息doSomethingWithConfig();</code></pre><p>上面代码中如果定义initialized变量时没有使用volatile修饰，就有可能会由于指令重排序的优化，导致线程A中最后一句代码 “initialized = true” 在 “doSomethingReadConfg()” 之前被执行，这样会导致线程B中使用配置信息的代码就可能出现错误，而volatile关键字就禁止重排序的语义可以避免此类情况发生。</p><h3 id="volatile型变量实现原理"><a href="#volatile型变量实现原理" class="headerlink" title="volatile型变量实现原理"></a>volatile型变量实现原理</h3><p>具体实现方式是在编译期生成字节码时，会在指令序列中增加内存屏障来保证，下面是基于保守策略的JMM内存屏障插入策略：</p><p><img src="/images/%E7%90%86%E8%A7%A3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/8.png" alt="volatile型变量内存屏障插入策略"></p><ul><li><p>在每个volatile写操作的前面插入一个StoreStore屏障。<br>该屏障除了保证了屏障之前的写操作和该屏障之后的写操作不能重排序，还会保证了volatile写操作之前，任何的读写操作都会先于volatile被提交。</p></li><li><p>在每个volatile写操作的后面插入一个StoreLoad屏障。<br>该屏障除了使volatile写操作不会与之后的读操作重排序外，还会刷新处理器缓存，使volatile变量的写更新对其他线程可见。</p></li><li><p>在每个volatile读操作的后面插入一个LoadLoad屏障。<br>该屏障除了使volatile读操作不会与之前的写操作发生重排序外，还会刷新处理器缓存，使volatile变量读取的为最新值。</p></li><li><p>在每个volatile读操作的后面插入一个LoadStore屏障。<br>该屏障除了禁止了volatile读操作与其之后的任何写操作进行重排序，还会刷新处理器缓存，使其他线程volatile变量的写更新对volatile读操作的线程可见。</p></li></ul><h3 id="volatile型变量使用场景"><a href="#volatile型变量使用场景" class="headerlink" title="volatile型变量使用场景"></a>volatile型变量使用场景</h3><p>总结起来，就是“一次写入，到处读取”，某一线程负责更新变量，其他线程只读取变量(不更新变量)，并根据变量的新值执行相应逻辑。例如状态标志位更新，观察者模型变量值发布。 </p><h2 id="4-6-final型变量的特殊规则"><a href="#4-6-final型变量的特殊规则" class="headerlink" title="4.6 final型变量的特殊规则"></a>4.6 final型变量的特殊规则</h2><p>我们知道，final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。<br>final关键字的可见性是指：被final修饰的字段在声明时或者构造器中，一旦初始化完成，那么在其他线程无须同步就能正确看见final字段的值。这是因为一旦初始化完成，final变量的值立刻回写到主内存。</p><h2 id="4-7-synchronized的特殊规则"><a href="#4-7-synchronized的特殊规则" class="headerlink" title="4.7 synchronized的特殊规则"></a>4.7 synchronized的特殊规则</h2><p>通过 synchronized关键字包住的代码区域，对数据的读写进行控制：</p><ul><li>读数据<br>当线程进入到该区域读取变量信息时，对数据的读取也不能从工作内存读取，只能从内存中读取，保证读到的是最新的值。</li><li>写数据<br>在同步区内对变量的写入操作，在离开同步区时就将当前线程内的数据刷新到内存中，保证更新的数据对其他线程的可见性。</li></ul><h2 id="4-8-long和double型变量的特殊规则"><a href="#4-8-long和double型变量的特殊规则" class="headerlink" title="4.8 long和double型变量的特殊规则"></a>4.8 long和double型变量的特殊规则</h2><p>Java内存模型要求lock、unlock、read、load、assign、use、store、write这8种操作都具有原子性，但是对于64位的数据类型(long和double)，在模型中特别定义相对宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作分为2次32位的操作来进行。也就是说虚拟机可选择不保证64位数据类型的load、store、read和write这4个操作的原子性。由于这种非原子性，有可能导致其他线程读到同步未完成的“32位的半个变量”的值。</p><p>不过实际开发中，Java内存模型强烈建议虚拟机把64位数据的读写实现为具有原子性，目前各种平台下的商用虚拟机都选择把64位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不需要把用到的long和double变量专门声明为volatile。</p><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><p>由于Java内存模型涉及系列规则，网上的文章大部分就是对这些规则进行解析，但是很多没有解释为什么需要这些规则，这些规则的作用，其实这是不利于初学者学习的，容易绕进去这些繁琐规则不知所以然，下面谈谈我的一点学习知识的个人体会：</p><p><strong>学习知识的过程不是等同于只是理解知识和记忆知识，而是要对知识解决的问题的输入和输出建立连接</strong>，知识的本质是解决问题，所以在学习之前要理解问题，理解这个问题要的输出和输出，而知识就是输入到输出的一个关系映射。知识的学习要结合大量的例子来<strong>理解这个映射关系，然后压缩知识</strong>，华罗庚说过：“把一本书读厚，然后再读薄”，解释的就是这个道理，先结合大量的例子理解知识，然后再压缩知识。</p><p>以学习Java内存模型为例：</p><ul><li>理解问题，明确输入输出<br>首先理解Java内存模型是什么，有什么用，解决什么问题</li><li>理解内存模型系列协议<br>结合大量例子理解这些协议规则</li><li>压缩知识<br>大量规则其实就是通过数据同步协议，保证内存副本之间的数据一致性，同时防止重排序对程序的影响。</li></ul><p>希望对大家有帮助。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入学习Java虚拟机》</p><p><a href="https://time.geekbang.org/column/intro/108?code=XamkmJYooKBPKe8hT7otClsFDeVHb6rptMYHTdgiRPU%3D" target="_blank" rel="noopener">深入拆解Java虚拟机</a></p><p><a href="https://time.geekbang.org/column/article/13484?code=XamkmJYooKBPKe8hT7otClsFDeVHb6rptMYHTdgiRPU%3D" target="_blank" rel="noopener">Java核心技术36讲</a></p><p><a href="http://gee.cs.oswego.edu/dl/cpj/jmm.html" target="_blank" rel="noopener">Synchronization and the Java Memory Model ——Doug Lea</a></p><p><a href="https://www.infoq.cn/article/java-memory-model-1" target="_blank" rel="noopener">深入理解 Java 内存模型</a></p><p><a href="https://blog.csdn.net/kuangzhanshatian/article/details/47949059" target="_blank" rel="noopener">Java内存屏障和可见性</a></p><p><a href="https://www.jianshu.com/p/43af2cc32f90" target="_blank" rel="noopener">内存屏障与synchronized、volatile的原理</a></p><p><img src="/images/%E7%90%86%E8%A7%A3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/9.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>理解Java并发底层之AQS实现</title>
      <link href="/2019/10/13/li-jie-java-bing-fa-di-ceng-zhi-aqs-shi-xian/"/>
      <url>/2019/10/13/li-jie-java-bing-fa-di-ceng-zhi-aqs-shi-xian/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E7%90%86%E8%A7%A3Java%E5%B9%B6%E5%8F%91%E5%BA%95%E5%B1%82%E4%B9%8BAQS%E5%AE%9E%E7%8E%B0/0.png" alt><br>jdk的JUC包(java.util.concurrent)提供大量Java并发工具提供使用，基本由Doug Lea编写，很多地方值得学习和借鉴，是进阶升级必经之路</p><p>本文从JUC包中常用的对象锁、并发工具的使用和功能特性入手，带着问题，由浅到深，一步步剖析并发底层AQS抽象类具体实现</p><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><h2 id="1-AQS"><a href="#1-AQS" class="headerlink" title="1 AQS"></a>1 AQS</h2><p>AQS是一个抽象类，类全路径java.util.concurrent.locks.AbstractQueuedSynchronizer，抽象队列同步器，是基于模板模式开发的并发工具抽象类，有如下并发类基于AQS实现：</p><p><img src="/images/%E7%90%86%E8%A7%A3Java%E5%B9%B6%E5%8F%91%E5%BA%95%E5%B1%82%E4%B9%8BAQS%E5%AE%9E%E7%8E%B0/1.png" alt></p><h2 id="2-CAS"><a href="#2-CAS" class="headerlink" title="2 CAS"></a>2 CAS</h2><p>CAS是Conmpare And Swap(比较和交换)的缩写，是一个原子操作指令</p><p>CAS机制当中使用了3个基本操作数：内存地址addr，预期旧的值oldVal，要修改的新值newVal<br>更新一个变量的时候，只有当变量的预期值oldVal和内存地址addr当中的实际值相同时，才会将内存地址addr对应的值修改为newVal</p><p>基于乐观锁的思路，通过CAS再不断尝试和比较，可以对变量值线程安全地更新</p><h2 id="3-线程中断"><a href="#3-线程中断" class="headerlink" title="3 线程中断"></a>3 线程中断</h2><p>线程中断是一种线程协作机制，用于协作其他线程中断任务的执行</p><p>当线程处于阻塞等待状态，例如调用了wait()、join()、sleep()方法之后，调用线程的interrupt()方法之后，线程会马上退出阻塞并收到InterruptedException；</p><p>当线程处于运行状态，调用线程的interrupt()方法之后，线程并不会马上中断执行，需要在线程的具体任务执行逻辑中通过调用isInterrupted() 方法检测线程中断标志位，然后主动响应中断，通常是抛出InterruptedException</p><h1 id="对象锁特性"><a href="#对象锁特性" class="headerlink" title="对象锁特性"></a>对象锁特性</h1><p>下面先介绍对象锁、并发工具有哪些基本特性，后面再逐步展开这些特性如何实现</p><h2 id="1-显式获取"><a href="#1-显式获取" class="headerlink" title="1 显式获取"></a>1 显式获取</h2><p>以ReentrantLock锁为例，主要支持以下4种方式显式获取锁</p><ul><li><p><strong>(1) 阻塞等待获取</strong></p><pre><code>ReentrantLock lock = new ReentrantLock();// 一直阻塞等待，直到获取成功lock.lock();</code></pre></li><li><p><strong>(2) 无阻塞尝试获取</strong></p><pre><code>ReentrantLock lock = new ReentrantLock();// 尝试获取锁，如果锁已被其他线程占用，则不阻塞等待直接返回false// 返回true - 锁是空闲的且被本线程获取，或者已经被本线程持有// 返回false - 获取锁失败boolean isGetLock = lock.tryLock();</code></pre></li><li><p><strong>(3) 指定时间内阻塞等待获取</strong></p><pre><code>ReentrantLock lock = new ReentrantLock();try {  // 尝试在指定时间内获取锁  // 返回true - 锁是空闲的且被本线程获取，或者已经被本线程持有  // 返回false - 指定时间内未获取到锁  lock.tryLock(10, TimeUnit.SECONDS);} catch (InterruptedException e) {  // 内部调用isInterrupted() 方法检测线程中断标志位，主动响应中断  e.printStackTrace();}</code></pre></li><li><p><strong>(4) 响应中断获取</strong></p><pre><code>ReentrantLock lock = new ReentrantLock();try {  // 响应中断获取锁  // 如果调用线程的thread.interrupt()方法设置线程中断，线程退出阻塞等待并抛出中断异常  lock.lockInterruptibly();} catch (InterruptedException e) {  e.printStackTrace();}</code></pre></li></ul><h2 id="2-显式释放"><a href="#2-显式释放" class="headerlink" title="2 显式释放"></a>2 显式释放</h2><pre><code>ReentrantLock lock = new ReentrantLock();lock.lock();// ... 各种业务操作// 显式释放锁lock.unlock();</code></pre><h2 id="3-可重入"><a href="#3-可重入" class="headerlink" title="3 可重入"></a>3 可重入</h2><p>已经获取到锁的线程，再次请求该锁可以直接获得</p><h2 id="4-可共享"><a href="#4-可共享" class="headerlink" title="4 可共享"></a>4 可共享</h2><p>指同一个资源允许多个线程共享，例如读写锁的读锁允许多个线程共享，共享锁可以让多个线程并发安全地访问数据，提高程序执效率</p><h2 id="5-公平、非公平"><a href="#5-公平、非公平" class="headerlink" title="5 公平、非公平"></a>5 公平、非公平</h2><p>公平锁：多个线程采用先到先得的公平方式竞争锁。每次加锁前都会检查等待队列里面有没有线程排队，没有才会尝试获取锁。<br>非公平锁：当一个线程采用非公平的方式获取锁时，该线程会首先去尝试获取锁而不是等待。如果没有获取成功，才会进入等待队列</p><p>因为非公平锁方式可以使后来的线程有一定几率直接获取锁，减少了线程挂起等待的几率，性能优于公平锁</p><h1 id="AQS实现原理"><a href="#AQS实现原理" class="headerlink" title="AQS实现原理"></a>AQS实现原理</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h2><h3 id="1-Condition接口"><a href="#1-Condition接口" class="headerlink" title="(1) Condition接口"></a>(1) Condition接口</h3><p>类似Object的wait()、wait(long timeout)、notify()以及notifyAll()的方法结合synchronized内置锁可以实现可以实现等待/通知模式，实现Lock接口的ReentrantLock、ReentrantReadWriteLock等对象锁也有类似功能：</p><p>Condition接口定义了await()、awaitNanos(long)、signal()、signalAll()等方法，配合对象锁实例实现等待/通知功能，原理是基于AQS内部类ConditionObject实现Condition接口，线程await后阻塞并进入CLH队列(下面提到)，等待其他线程调用signal方法后被唤醒</p><h3 id="2-CLH队列"><a href="#2-CLH队列" class="headerlink" title="(2) CLH队列"></a>(2) CLH队列</h3><p>CLH队列，CLH是算法提出者Craig, Landin, Hagersten的名字简称</p><p>AQS内部维护着一个双向FIFO的CLH队列，AQS依赖它来管理等待中的线程，如果线程获取同步竞争资源失败时，会将线程阻塞，并加入到CLH同步队列；当竞争资源空闲时，基于CLH队列阻塞线程并分配资源</p><p>CLH的head节点保存当前占用资源的线程，或者是没有线程信息，其他节点保存排队线程信息</p><p><img src="/images/%E7%90%86%E8%A7%A3Java%E5%B9%B6%E5%8F%91%E5%BA%95%E5%B1%82%E4%B9%8BAQS%E5%AE%9E%E7%8E%B0/2.png" alt="CLH"><br>CLH中每一个节点的状态(waitStatus)取值如下：</p><ul><li><strong>CANCELLED(1)</strong>：表示当前节点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的节点将不会再变化</li><li><strong>SIGNAL(-1)</strong>：表示后继节点在等待当前节点唤醒。后继节点入队后进入休眠状态之前，会将前驱节点的状态更新为SIGNAL</li><li><strong>CONDITION(-2)</strong>：表示节点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的节点将从等待队列转移到同步队列中，等待获取同步锁</li><li><strong>PROPAGATE(-3)</strong>：共享模式下，前驱节点不仅会唤醒其后继节点，同时也可能会唤醒后继的后继节点</li><li><strong>0</strong>：新节点入队时的默认状态</li></ul><h3 id="3-资源共享方式"><a href="#3-资源共享方式" class="headerlink" title="(3) 资源共享方式"></a>(3) 资源共享方式</h3><p>AQS定义两种资源共享方式：<br>Exclusive 独占，只有一个线程能执行，如ReentrantLock<br>Share 共享，多个线程可同时执行，如Semaphore/CountDownLatch</p><h3 id="4-阻塞-唤醒线程的方式"><a href="#4-阻塞-唤醒线程的方式" class="headerlink" title="(4) 阻塞/唤醒线程的方式"></a>(4) 阻塞/唤醒线程的方式</h3><p>AQS 基于sun.misc.Unsafe类提供的park方法阻塞线程，unpark方法唤醒线程，被park方法阻塞的线程能响应interrupt()中断请求退出阻塞</p><h2 id="2-基本设计"><a href="#2-基本设计" class="headerlink" title="2 基本设计"></a>2 基本设计</h2><p>核心设计思路：AQS提供一个框架，用于实现依赖于CLH队列的阻塞锁和相关的并发同步器。<strong>子类通过实现判定是否能获取/释放资源的protect方法，AQS基于这些protect方法实现对线程的排队、唤醒的线程调度策略</strong></p><p>AQS还提供一个支持线程安全原子更新的int类型变量作为同步状态值(state)，子类可以根据实际需求，灵活定义该变量代表的意义进行更新</p><p>通过子类重新定义的系列protect方法如下：</p><ul><li>boolean tryAcquire(int) 独占方式尝试获取资源，成功则返回true，失败则返回false</li><li>boolean tryRelease(int) 独占方式尝试释放资源，成功则返回true，失败则返回false</li><li>int tryAcquireShared(int) 共享方式尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源</li><li>boolean tryReleaseShared(int) 共享方式尝试释放资源，如果释放后允许唤醒后续等待节点返回true，否则返回false</li></ul><p>这些方法始终由需要需要调度协作的线程来调用，子类须以非阻塞的方式重新定义这些方法</p><p>AQS基于上述tryXXX方法，对外提供下列方法来获取/释放资源：</p><ul><li>void acquire(int) 独占方式获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响</li><li>boolean release(int) 独占方式下线程释放资源，先释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源</li><li>void acquireShared(int) 独占方式获取资源</li><li>boolean releaseShared(int) 共享方式释放资源</li></ul><p>以独占模式为例：获取/释放资源的核心的实现如下：</p><pre><code> Acquire:     while (!tryAcquire(arg)) {        如果线程尚未排队，则将其加入队列；     } Release:     if (tryRelease(arg))        唤醒CLH中第一个排队线程</code></pre><p>到这里，有点绕，下面一张图把上面介绍到的设计思路再重新捋一捋：</p><p><img src="/images/%E7%90%86%E8%A7%A3Java%E5%B9%B6%E5%8F%91%E5%BA%95%E5%B1%82%E4%B9%8BAQS%E5%AE%9E%E7%8E%B0/3.png" alt="AQS基本设计"></p><h1 id="特性实现"><a href="#特性实现" class="headerlink" title="特性实现"></a>特性实现</h1><p>下面介绍基于AQS的对象锁、并发工具的一系列功能特性的实现原理</p><h2 id="1-显式获取-1"><a href="#1-显式获取-1" class="headerlink" title="1 显式获取"></a>1 显式获取</h2><p>该特性还是以ReentrantLock锁为例，ReentrantLock是可重入对象锁，线程每次请求获取成功一次锁，同步状态值state加1，释放锁state减1，state为0代表没有任何线程持有锁</p><p>ReentrantLock锁支持公平/非公平特性，下面的显式获取特性以公平锁为例</p><h3 id="1-阻塞等待获取"><a href="#1-阻塞等待获取" class="headerlink" title="(1) 阻塞等待获取"></a>(1) 阻塞等待获取</h3><p>基本实现如下：</p><ul><li>1、ReentrantLock实现AQS的tryAcquire(int)方法，先判断：如果没有任何线程持有锁，或者当前线程已经持有锁，则返回true，否则返回false</li><li>2、AQS的acquire(int)方法判断当前节点是否为head且基于tryAcquire(int)能否获得资源，如果不能获得，则加入CLH队列排队阻塞等待</li><li>3、ReentrantLock的lock()方法基于AQS的acquire(int)方法阻塞等待获取锁</li></ul><p>ReentrantLock中的tryAcquire(int)方法实现：</p><pre><code>protected final boolean tryAcquire(int acquires) {    final Thread current = Thread.currentThread();    int c = getState();    // 没有任何线程持有锁    if (c == 0) {        // 通过CLH队列的head判断没有别的线程在比当前更早acquires        // 且基于CAS设置state成功(期望的state旧值为0)        if (!hasQueuedPredecessors() &amp;&amp;            compareAndSetState(0, acquires)) {            // 设置持有锁的线程为当前线程            setExclusiveOwnerThread(current);            return true;        }    }    // 持有锁的线程为当前线程    else if (current == getExclusiveOwnerThread()) {        // 仅仅在当前线程，单线程，不用基于CAS更新        int nextc = c + acquires;        if (nextc &lt; 0)            throw new Error(&quot;Maximum lock count exceeded&quot;);        setState(nextc);        return true;    }    // 其他线程已经持有锁    return false;}</code></pre><p>AQS的acquire(int)方法实现</p><pre><code>public final void acquire(int arg) {        // tryAcquire检查释放能获取成功        // addWaiter 构建CLH的节点对象并入队        // acquireQueued线程阻塞等待    if (!tryAcquire(arg) &amp;&amp;        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))        // acquireQueued返回true，代表线程在获取资源的过程中被中断        // 则调用该方法将线程中断标志位设置为true        selfInterrupt();}final boolean acquireQueued(final Node node, int arg) {    // 标记是否成功拿到资源    boolean failed = true;    try {        // 标记等待过程中是否被中断过        boolean interrupted = false;        // 循环直到资源释放        for (;;) {            // 拿到前驱节点            final Node p = node.predecessor();            // 如果前驱是head，即本节点是第二个节点，才有资格去尝试获取资源            // 可能是head释放完资源唤醒本节点，也可能被interrupt()            if (p == head &amp;&amp; tryAcquire(arg)) {                // 成功获取资源                setHead(node);                // help GC                p.next = null;                 failed = false;                return interrupted;            }            // 需要排队阻塞等待            // 如果在过程中线程中断，不响应中断            // 且继续排队获取资源，设置interrupted变量为true            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                parkAndCheckInterrupt())                interrupted = true;        }    } finally {        if (failed)            cancelAcquire(node);    }}</code></pre><h3 id="2-无阻塞尝试获取"><a href="#2-无阻塞尝试获取" class="headerlink" title="(2) 无阻塞尝试获取"></a>(2) 无阻塞尝试获取</h3><p>ReentrantLock中的tryLock()的实现仅仅是非公平锁实现，实现逻辑基本与tryAcquire一致，不同的是没有通过hasQueuedPredecessors()检查CLH队列的head是否有其他线程在等待，这样当资源释放时，有线程请求资源能插队优先获取</p><p>ReentrantLock中tryLock()具体实现如下：</p><pre><code>public boolean tryLock() {    return sync.nonfairTryAcquire(1);}final boolean nonfairTryAcquire(int acquires) {    final Thread current = Thread.currentThread();    int c = getState();    // 没有任何线程持有锁    if (c == 0) {        // 基于CAS设置state成功(期望的state旧值为0)        // 没有检查CLH队列中是否有线程在等待        if (compareAndSetState(0, acquires)) {            setExclusiveOwnerThread(current);            return true;        }    }    // 持有锁的线程为当前线程    else if (current == getExclusiveOwnerThread()) {        // 仅仅在当前线程，单线程，不用基于CAS更新        int nextc = c + acquires;        if (nextc &lt; 0) // overflow，整数溢出            throw new Error(&quot;Maximum lock count exceeded&quot;);        setState(nextc);        return true;    }    // 其他线程已经持有锁    return false;}</code></pre><h3 id="3-指定时间内阻塞等待获取"><a href="#3-指定时间内阻塞等待获取" class="headerlink" title="(3) 指定时间内阻塞等待获取"></a>(3) 指定时间内阻塞等待获取</h3><p>基本实现如下：</p><ul><li>1、ReentrantLock的tryLock(long, TimeUnit)调用AQS的tryAcquireNanos(int, long)方法</li><li>2、AQS的tryAcquireNanos先调用tryAcquire(int)尝试获取，获取不到再调用doAcquireNanos(int, long)方法</li><li>3、AQS的doAcquireNanos判断当前节点是否为head且基于tryAcquire(int)能否获得资源，如果不能获得且超时时间大于1微秒，则休眠一段时间后再尝试获取</li></ul><p>ReentrantLock中的实现如下：</p><pre><code>public boolean tryLock(long timeout, TimeUnit unit)        throws InterruptedException {    return sync.tryAcquireNanos(1, unit.toNanos(timeout));}public final boolean tryAcquireNanos(int arg, long nanosTimeout)        throws InterruptedException {    // 如果线程已经被interrupt()方法设置中断        if (Thread.interrupted())        throw new InterruptedException();    // 先tryAcquire尝试获取锁        return tryAcquire(arg) ||        doAcquireNanos(arg, nanosTimeout);}</code></pre><p>AQS中的实现如下：</p><pre><code>private boolean doAcquireNanos(int arg, long nanosTimeout)        throws InterruptedException {    if (nanosTimeout &lt;= 0L)        return false;    // 获取到资源的截止时间        final long deadline = System.nanoTime() + nanosTimeout;    final Node node = addWaiter(Node.EXCLUSIVE);    // 标记是否成功拿到资源    boolean failed = true;    try {        for (;;) {            // 拿到前驱节点            final Node p = node.predecessor();            // 如果前驱是head，即本节点是第二个节点，才有资格去尝试获取资源            // 可能是head释放完资源唤醒本节点，也可能被interrupt()            if (p == head &amp;&amp; tryAcquire(arg)) {                // 成功获取资源                setHead(node);                // help GC                p.next = null;                 failed = false;                return true;            }            // 更新剩余超时时间            nanosTimeout = deadline - System.nanoTime();            if (nanosTimeout &lt;= 0L)                return false;            // 排队是否需要排队阻塞等待                // 且超时时间大于1微秒，则线程休眠到超时时间到了再尝试获取            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                nanosTimeout &gt; spinForTimeoutThreshold)                LockSupport.parkNanos(this, nanosTimeout);            // 如果线程已经被interrupt()方法设置中断            // 则不再排队，直接退出                 if (Thread.interrupted())                throw new InterruptedException();        }    } finally {        if (failed)            cancelAcquire(node);    }}</code></pre><h3 id="4-响应中断获取"><a href="#4-响应中断获取" class="headerlink" title="(4) 响应中断获取"></a>(4) 响应中断获取</h3><p>ReentrantLock响应中断获取锁的方式是：当线程在park方法休眠中响应thead.interrupt()方法中断唤醒时，检查到线程中断标志位为true，主动抛出异常，核心实现在AQS的doAcquireInterruptibly(int)方法中</p><p>基本实现与阻塞等待获取类似，只是调用从AQS的acquire(int)方法，改为调用AQS的doAcquireInterruptibly(int)方法</p><pre><code>private void doAcquireInterruptibly(int arg)    throws InterruptedException {    final Node node = addWaiter(Node.EXCLUSIVE);    // 标记是否成功拿到资源    boolean failed = true;    try {        for (;;) {            // 拿到前驱节点            final Node p = node.predecessor();            // 如果前驱是head，即本节点是第二个节点，才有资格去尝试获取资源            // 可能是head释放完资源唤醒本节点，也可能被interrupt()            if (p == head &amp;&amp; tryAcquire(arg)) {                // 成功获取资源                setHead(node);                p.next = null; // help GC                failed = false;                return;            }            // 需要排队阻塞等待            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                // 从排队阻塞中唤醒，如果检查到中断标志位为true                parkAndCheckInterrupt())                // 主动响应中断                throw new InterruptedException();        }    } finally {        if (failed)            cancelAcquire(node);    }}</code></pre><h2 id="2-显式释放-1"><a href="#2-显式释放-1" class="headerlink" title="2 显式释放"></a>2 显式释放</h2><p>AQS资源共享方式分为独占式和共享式，这里先以ReentrantLock为例介绍独占式资源的显式释放，共享式后面会介绍到</p><p>与显式获取有类似之处，ReentrantLock显式释放基本实现如下：</p><ul><li>1、ReentrantLock实现AQS的tryRelease(int)方法，方法将state变量减1，如果state变成0代表没有任何线程持有锁，返回true，否则返回false</li><li>2、AQS的release(int)方法基于tryRelease(int)排队是否有任何线程持有资源，如果没有，则唤醒CLH队列中头节点的线程</li><li>3、被唤醒后的线程继续执行acquireQueued(Node,int)或者doAcquireNanos(int, long)或者doAcquireInterruptibly(int)中for(;;)中的逻辑，继续尝试获取资源</li></ul><p>ReentrantLock中tryRelease(int)方法实现如下：</p><pre><code>protected final boolean tryRelease(int releases) {    int c = getState() - releases;    // 只有持有锁的线程才有资格释放锁    if (Thread.currentThread() != getExclusiveOwnerThread())        throw new IllegalMonitorStateException();    // 标识是否没有任何线程持有锁        boolean free = false;    // 没有任何线程持有锁    // 可重入锁每lock一次都需要对应一次unlock    if (c == 0) {        free = true;        setExclusiveOwnerThread(null);    }    setState(c);    return free;}</code></pre><p>AQS中的release(int)方法实现如下：</p><pre><code>public final boolean release(int arg) {    // 尝试释放资源    if (tryRelease(arg)) {        Node h = head;        // 头节点不为空        // 后继节点入队后进入休眠状态之前，会将前驱节点的状态更新为SIGNAL(-1)        // 头节点状态为0，代表没有后继的等待节点        if (h != null &amp;&amp; h.waitStatus != 0)            // 唤醒第二个节点            // 头节点是占用资源的线程，第二个节点才是首个等待资源的线程            unparkSuccessor(h);        return true;    }    return false;}</code></pre><h2 id="3-可重入-1"><a href="#3-可重入-1" class="headerlink" title="3 可重入"></a>3 可重入</h2><p>可重入的实现比较简单，以ReentrantLock为例，主要是在tryAcquire(int)方法中实现，持有锁的线程是不是当前线程，如果是，更新同步状态值state，并返回true，代表能获取锁</p><h2 id="4-可共享-1"><a href="#4-可共享-1" class="headerlink" title="4 可共享"></a>4 可共享</h2><p>可共享资源以ReentrantReadWriteLock为例，跟独占锁ReentrantLock的区别主要在于，获取的时候，多个线程允许共享读锁，当写锁释放时，多个阻塞等待读锁的线程能同时获取到</p><p>ReentrantReadWriteLock类中将AQS的state同步状态值定义为，高16位为读锁持有数，低16位为写锁持有锁</p><p>ReentrantReadWriteLock中tryAcquireShared(int)、tryReleaseShared(int)实现的逻辑较长，主要涉及读写互斥、可重入判断、读锁对写锁的让步，篇幅所限，这里就不展开了</p><p><strong>获取读锁(ReadLock.lock())主要实现如下</strong>：</p><ul><li>1、ReentrantReadWriteLock实现AQS的tryAcquireShared(int)方法，判断当前线程能否获得读锁</li><li>2、AQS的acquireShared(int)先基于tryAcquireShared(int)尝试获取资源，如果获取失败，则加入CLH队列排队阻塞等待</li><li>3、ReentrantReadWriteLock的ReadLock.lock()方法基于AQS的acquireShared(int)方法阻塞等待获取锁</li></ul><p>AQS共享模式获取资源的具体实现如下：</p><pre><code>public final void acquireShared(int arg) {    // tryAcquireShared返回负数代表获取共享资源失败    // 则通过进入等待队列，直到获取到资源为止才返回    if (tryAcquireShared(arg) &lt; 0)        doAcquireShared(arg);}// 与前面介绍到的acquireQueued逻辑基本一致// 不同的是将tryAcquire改为tryAcquireShared// 还有资源获取成功后将传播给CLH队列上等待该资源的节点private void doAcquireShared(int arg) {    final Node node = addWaiter(Node.SHARED);     // 标记是否成功拿到资源    boolean failed = true;    try {        boolean interrupted = false;        for (;;) {            final Node p = node.predecessor();            if (p == head) {                int r = tryAcquireShared(arg);                // 资源获取成功                if (r &gt;= 0) {                     // 传播给CLH队列上等待该资源的节点                                                 setHeadAndPropagate(node, r);                    p.next = null; // help GC                    if (interrupted)                        selfInterrupt();                    failed = false;                    return;                }            }            // 需要排队阻塞等待            // 如果在过程中线程中断，不响应中断            // 且继续排队获取资源，设置interrupted变量为true            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                parkAndCheckInterrupt())                interrupted = true;        }    } finally {        if (failed)            cancelAcquire(node);    }}//  资源传播给CLH队列上等待该资源的节点 private void setHeadAndPropagate(Node node, int propagate) {    Node h = head;     setHead(node);    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||        (h = head) == null || h.waitStatus &lt; 0) {        Node s = node.next;        if (s == null || s.isShared())            // 释放共享资源            doReleaseShared();    }}</code></pre><p><strong>释放读锁(ReadLock.unlock())主要实现如下</strong>：<br>ReentrantReadWriteLock共享资源的释放主要实现如下：</p><ul><li>1、ReentrantReadWriteLock实现AQS的tryReleaseShared(int)方法，判断读锁释放后是否还有线程持有读锁</li><li>2、AQS的releaseShared(int)基于tryReleaseShared(int)判断是否需要CLH队列中的休眠线程，如果需要就执行doReleaseShared()</li><li>3、ReentrantReadWriteLock的ReadLock.unlock()方法基于AQS的releaseShared(int)方法释放锁</li></ul><p>AQS共享模式释放资源具体实现如下：</p><pre><code>public final boolean releaseShared(int arg) {    // 允许唤醒CLH中的休眠线程    if (tryReleaseShared(arg)) {        // 执行资源释放        doReleaseShared();        return true;    }    return false;}private void doReleaseShared() {    for (;;) {        Node h = head;        if (h != null &amp;&amp; h != tail) {            int ws = h.waitStatus;            // 当前节点正在等待资源            if (ws == Node.SIGNAL) {                // 当前节点被其他线程唤醒了                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))                    continue;                            unparkSuccessor(h);            }            // 进入else的条件是，当前节点刚刚成为头节点            // 尾节点刚刚加入CLH队列，还没在休眠前将前驱节点状态改为SIGNAL            // CAS失败是尾节点已经在休眠前将前驱节点状态改为SIGNAL            else if (ws == 0 &amp;&amp;                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))                continue;                       }        // 每次唤醒后驱节点后，线程进入doAcquireShared方法，然后更新head        // 如果h变量在本轮循环中没有被改变，说明head == tail，队列中节点全部被唤醒        if (h == head)                             break;    }}</code></pre><h2 id="5-公平、非公平-1"><a href="#5-公平、非公平-1" class="headerlink" title="5 公平、非公平"></a>5 公平、非公平</h2><p>这个特性实现比较简单，以ReentrantLock锁为例，公平锁直接基于AQS的acquire(int)获取资源，而非公平锁先尝试插队：基于CAS，期望state同步变量值为0(没有任何线程持有锁)，更新为1，如果全部CAS更新失败再进行排队</p><pre><code>// 公平锁实现final void lock() {    acquire(1);}// 非公平锁实现final void lock() {    // 第1次CAS    // state值为0代表没有任何线程持有锁，直接插队获得锁    if (compareAndSetState(0, 1))        setExclusiveOwnerThread(Thread.currentThread());    else        acquire(1);}protected final boolean tryAcquire(int acquires) {    return nonfairTryAcquire(acquires);}// 在nonfairTryAcquire方法中再次CAS尝试获取锁final boolean nonfairTryAcquire(int acquires) {    final Thread current = Thread.currentThread();    int c = getState();    if (c == 0) {        // 第2次CAS尝试获取锁        if (compareAndSetState(0, acquires)) {            setExclusiveOwnerThread(current);            return true;        }    }    // 已经获得锁    else if (current == getExclusiveOwnerThread()) {        int nextc = c + acquires;        if (nextc &lt; 0) // overflow            throw new Error(&quot;Maximum lock count exceeded&quot;);        setState(nextc);        return true;    }    return false;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>AQS的state变量值的含义不一定代表资源，不同的AQS的继承类可以对state变量值有不同的定义</p><p>例如在countDownLatch类中，state变量值代表还需释放的latch计数(可以理解为需要打开的门闩数)，需要每个门闩都打开，门才能打开，所有等待线程才会开始执行，每次countDown()就会对state变量减1，如果state变量减为0，则唤醒CLH队列中的休眠线程</p><p>学习类似底层源码建议先定几个问题，带着问题学习；通俗学习前建议先理解透彻整体设计，整体原理(可以先阅读相关文档资料)，再研究和源码细节，避免一开始就扎进去源码，容易无功而返</p><p><img src="/images/%E7%90%86%E8%A7%A3Java%E5%B9%B6%E5%8F%91%E5%BA%95%E5%B1%82%E4%B9%8BAQS%E5%AE%9E%E7%8E%B0/4.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
